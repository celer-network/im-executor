// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package eth

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// OriginalTokenVaultMetaData contains all meta data concerning the OriginalTokenVault contract.
var OriginalTokenVaultMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"_sigsVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"DelayPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"DelayThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"DelayedTransferAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DelayedTransferExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"depositId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"mintChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mintAccount\",\"type\":\"address\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"EpochLengthUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"EpochVolumeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxDepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MinDepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"withdrawId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"refChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"burnAccount\",\"type\":\"address\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delayThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"delayedTransfers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_mintChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_mintAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_mintChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_mintAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"depositNative\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumeCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"executeDelayedTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"governors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastOpTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeWrap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setDelayPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_thresholds\",\"type\":\"uint256[]\"}],\"name\":\"setDelayThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"setEpochLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_caps\",\"type\":\"uint256[]\"}],\"name\":\"setEpochVolumeCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMaxDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"name\":\"setWrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sigsVerifier\",\"outputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_request\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Bin: "0x60a06040523480156200001157600080fd5b506040516200372b3803806200372b833981016040819052620000349162000255565b6001600055620000443362000079565b6001805460ff60a01b191690556200005c33620000cb565b620000673362000195565b6001600160a01b031660805262000287565b600180546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6001600160a01b03811660009081526002602052604090205460ff16156200013a5760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c7265616479207061757365720000000000000060448201526064015b60405180910390fd5b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f891015b60405180910390a150565b6001600160a01b03811660009081526003602052604090205460ff1615620002005760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f720000000000604482015260640162000131565b6001600160a01b038116600081815260036020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b591016200018a565b6000602082840312156200026857600080fd5b81516001600160a01b03811681146200028057600080fd5b9392505050565b608051613481620002aa60003960008181610752015261176701526134816000f3fe6080604052600436106102885760003560e01c80636b2c0f5511610153578063adc0d57f116100cb578063e3eece261161007f578063eecdac8811610064578063eecdac88146107f2578063f2fde38b14610812578063f83213831461083257600080fd5b8063e3eece2614610789578063e43581b8146107b957600080fd5b8063b5f2bc47116100b0578063b5f2bc4714610713578063ccf2683b14610740578063e026049c1461077457600080fd5b8063adc0d57f14610683578063b1c94d94146106fd57600080fd5b80638456cb59116101225780639e25fc5c116101075780639e25fc5c146106235780639ff9001a14610643578063a21a92801461066357600080fd5b80638456cb59146105f05780638da5cb5b1461060557600080fd5b80636b2c0f551461056b5780636ef8d66d1461058b57806380f51c12146105a057806382dc1ec4146105d057600080fd5b8063402d267d1161020157806354eea796116101b55780635c975abb1161019a5780635c975abb146104ff5780635ec2fa261461051e57806360216b001461053e57600080fd5b806354eea796146104c957806357d775f8146104e957600080fd5b806346fbf68e116101e657806346fbf68e1461044357806347b16c6c1461047c57806352532faa1461049c57600080fd5b8063402d267d146103de578063457bfa2f1461040b57600080fd5b8063303b6442116102585780633c4a25d01161023d5780633c4a25d0146103895780633d572107146103a95780633f4ba83a146103c957600080fd5b8063303b64421461032e5780633c29f8391461034e57600080fd5b8062a95fd71461029457806301e64725146102a957806317bdbae5146102ee578063234636241461030e57600080fd5b3661028f57005b600080fd5b6102a76102a2366004612ea3565b61085f565b005b3480156102b557600080fd5b506102d96102c4366004612ef0565b600b6020526000908152604090205460ff1681565b60405190151581526020015b60405180910390f35b3480156102fa57600080fd5b506102a7610309366004612f55565b610ab7565b34801561031a57600080fd5b506102a7610329366004612fc1565b610c55565b34801561033a57600080fd5b506102a7610349366004612f55565b610d92565b34801561035a57600080fd5b5061037b61036936600461301f565b600c6020526000908152604090205481565b6040519081526020016102e5565b34801561039557600080fd5b506102a76103a436600461301f565b610f29565b3480156103b557600080fd5b506102a76103c4366004612ef0565b610f9e565b3480156103d557600080fd5b506102a7611032565b3480156103ea57600080fd5b5061037b6103f936600461301f565b600d6020526000908152604090205481565b34801561041757600080fd5b50600e5461042b906001600160a01b031681565b6040516001600160a01b0390911681526020016102e5565b34801561044f57600080fd5b506102d961045e36600461301f565b6001600160a01b031660009081526002602052604090205460ff1690565b34801561048857600080fd5b506102a7610497366004612f55565b61109b565b3480156104a857600080fd5b5061037b6104b736600461301f565b60096020526000908152604090205481565b3480156104d557600080fd5b506102a76104e4366004612ef0565b611232565b3480156104f557600080fd5b5061037b60045481565b34801561050b57600080fd5b50600154600160a01b900460ff166102d9565b34801561052a57600080fd5b506102a7610539366004612f55565b6112bf565b34801561054a57600080fd5b5061037b61055936600461301f565b60056020526000908152604090205481565b34801561057757600080fd5b506102a761058636600461301f565b611456565b34801561059757600080fd5b506102a76114c8565b3480156105ac57600080fd5b506102d96105bb36600461301f565b60026020526000908152604090205460ff1681565b3480156105dc57600080fd5b506102a76105eb36600461301f565b6114d1565b3480156105fc57600080fd5b506102a7611543565b34801561061157600080fd5b506001546001600160a01b031661042b565b34801561062f57600080fd5b506102a761063e366004612ef0565b6115aa565b34801561064f57600080fd5b506102a761065e36600461301f565b61161f565b34801561066f57600080fd5b506102a761067e36600461303a565b6116aa565b34801561068f57600080fd5b506106d261069e366004612ef0565b60086020526000908152604090208054600182015460028301546003909301546001600160a01b0392831693919092169184565b604080516001600160a01b0395861681529490931660208501529183015260608201526080016102e5565b34801561070957600080fd5b5061037b600a5481565b34801561071f57600080fd5b5061037b61072e36600461301f565b60066020526000908152604090205481565b34801561074c57600080fd5b5061042b7f000000000000000000000000000000000000000000000000000000000000000081565b34801561078057600080fd5b506102a7611a66565b34801561079557600080fd5b506102d96107a436600461301f565b60036020526000908152604090205460ff1681565b3480156107c557600080fd5b506102d96107d436600461301f565b6001600160a01b031660009081526003602052604090205460ff1690565b3480156107fe57600080fd5b506102a761080d36600461301f565b611a6f565b34801561081e57600080fd5b506102a761082d36600461301f565b611ae1565b34801561083e57600080fd5b5061037b61084d36600461301f565b60076020526000908152604090205481565b6002600054036108b65760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b6002600055600154600160a01b900460ff16156109085760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108ad565b8334146109575760405162461bcd60e51b815260206004820152600f60248201527f416d6f756e74206d69736d61746368000000000000000000000000000000000060448201526064016108ad565b600e546001600160a01b03166109af5760405162461bcd60e51b815260206004820152601360248201527f4e61746976652077726170206e6f74207365740000000000000000000000000060448201526064016108ad565b600e546000906109cb906001600160a01b031686868686611bcf565b9050600e60009054906101000a90046001600160a01b03166001600160a01b031663d0e30db0866040518263ffffffff1660e01b81526004016000604051808303818588803b158015610a1d57600080fd5b505af1158015610a31573d6000803e3d6000fd5b5050600e54604080518681523360208201526001600160a01b0392831691810191909152606081018a905267ffffffffffffffff8916608082015290871660a08201527f15d2eeefbe4963b5b2178f239ddcc730dda55f1c23c22efb79ded0eb854ac789935060c0019150610aa39050565b60405180910390a150506001600055505050565b3360009081526003602052604090205460ff16610b0f5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108ad565b828114610b505760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108ad565b60005b83811015610c4e57828282818110610b6d57610b6d613129565b9050602002013560096000878785818110610b8a57610b8a613129565b9050602002016020810190610b9f919061301f565b6001600160a01b031681526020810191909152604001600020557fceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce858583818110610bec57610bec613129565b9050602002016020810190610c01919061301f565b848484818110610c1357610c13613129565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610c4681613155565b915050610b53565b5050505050565b600260005403610ca75760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016108ad565b6002600055600154600160a01b900460ff1615610cf95760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108ad565b6000610d088686868686611bcf565b9050610d1f6001600160a01b038716333088611dc5565b604080518281523360208201526001600160a01b03888116828401526060820188905267ffffffffffffffff87166080830152851660a082015290517f15d2eeefbe4963b5b2178f239ddcc730dda55f1c23c22efb79ded0eb854ac7899181900360c00190a15050600160005550505050565b3360009081526003602052604090205460ff16610dea5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108ad565b828114610e2b5760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108ad565b60005b83811015610c4e57828282818110610e4857610e48613129565b90506020020135600d6000878785818110610e6557610e65613129565b9050602002016020810190610e7a919061301f565b6001600160a01b031681526020810191909152604001600020557f0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72858583818110610ec757610ec7613129565b9050602002016020810190610edc919061301f565b848484818110610eee57610eee613129565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610f2181613155565b915050610e2e565b33610f3c6001546001600160a01b031690565b6001600160a01b031614610f925760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108ad565b610f9b81611e63565b50565b3360009081526003602052604090205460ff16610ff65760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108ad565b600a8190556040518181527fc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6906020015b60405180910390a150565b3360009081526002602052604090205460ff166110915760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f742070617573657200000000000000000000000060448201526064016108ad565b611099611f20565b565b3360009081526003602052604090205460ff166110f35760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108ad565b8281146111345760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108ad565b60005b83811015610c4e5782828281811061115157611151613129565b905060200201356006600087878581811061116e5761116e613129565b9050602002016020810190611183919061301f565b6001600160a01b031681526020810191909152604001600020557f608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e898585838181106111d0576111d0613129565b90506020020160208101906111e5919061301f565b8484848181106111f7576111f7613129565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a18061122a81613155565b915050611137565b3360009081526003602052604090205460ff1661128a5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108ad565b60048190556040518181527f2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b390602001611027565b3360009081526003602052604090205460ff166113175760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108ad565b8281146113585760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108ad565b60005b83811015610c4e5782828281811061137557611375613129565b90506020020135600c600087878581811061139257611392613129565b90506020020160208101906113a7919061301f565b6001600160a01b031681526020810191909152604001600020557f0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba68585838181106113f4576113f4613129565b9050602002016020810190611409919061301f565b84848481811061141b5761141b613129565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a18061144e81613155565b91505061135b565b336114696001546001600160a01b031690565b6001600160a01b0316146114bf5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108ad565b610f9b81611fc6565b61109933611fc6565b336114e46001546001600160a01b031690565b6001600160a01b03161461153a5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108ad565b610f9b8161207f565b3360009081526002602052604090205460ff166115a25760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f742070617573657200000000000000000000000060448201526064016108ad565b61109961213c565b600154600160a01b900460ff16156115f75760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108ad565b6000611602826121c4565b905061161b816000015182602001518360400151612389565b5050565b336116326001546001600160a01b031690565b6001600160a01b0316146116885760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108ad565b600e80546001600160a01b0319166001600160a01b0392909216919091179055565b600154600160a01b900460ff16156116f75760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108ad565b6000463060405160200161174d92919091825260601b6bffffffffffffffffffffffff191660208201527f57697468647261770000000000000000000000000000000000000000000000006034820152603c0190565b6040516020818303038152906040528051906020012090507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663682dbc22828b8b6040516020016117a99392919061316e565b6040516020818303038152906040528989898989896040518863ffffffff1660e01b81526004016117e09796959493929190613293565b60006040518083038186803b1580156117f857600080fd5b505afa15801561180c573d6000803e3d6000fd5b5050505060006118518a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506124be92505050565b6020818101518251604080850151606080870151608088015160a0890151855197841b6bffffffffffffffffffffffff19908116898b015296841b871660348901526048880194909452911b909316606885015260c09290921b77ffffffffffffffffffffffffffffffffffffffffffffffff1916607c8401526084808401929092528051808403909201825260a490920182528051908301206000818152600b9093529120549192509060ff161561193c5760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b60448201526064016108ad565b6000818152600b602052604090819020805460ff19166001179055825190830151611967919061261a565b81516001600160a01b031660009081526009602052604090205480158015906119935750808360400151115b156119b5576119b082846020015185600001518660400151612738565b6119cc565b6119cc836020015184600001518560400151612389565b602080840151845160408087015160808089015160a0808b01516060808d015187518d81526001600160a01b039a8b169b81019b909b52978916968a01969096529488019390935267ffffffffffffffff16908601528401521660c08201527f296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb9060e00160405180910390a1505050505050505050505050565b6110993361284b565b33611a826001546001600160a01b031690565b6001600160a01b031614611ad85760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108ad565b610f9b8161284b565b33611af46001546001600160a01b031690565b6001600160a01b031614611b4a5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108ad565b6001600160a01b038116611bc65760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016108ad565b610f9b81612904565b6001600160a01b0385166000908152600c60205260408120548511611c365760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f20736d616c6c0000000000000000000000000000000060448201526064016108ad565b6001600160a01b0386166000908152600d60205260409020541580611c7357506001600160a01b0386166000908152600d60205260409020548511155b611cbf5760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f206c617267650000000000000000000000000000000060448201526064016108ad565b6040516bffffffffffffffffffffffff1933606090811b8216602084015288811b821660348401526048830188905277ffffffffffffffffffffffffffffffffffffffffffffffff1960c088811b821660688601529187901b909216607084015284811b8216608484015246901b16608c82015260009060940160408051601f1981840301815291815281516020928301206000818152600b90935291205490915060ff1615611da15760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b60448201526064016108ad565b6000818152600b60205260409020805460ff19166001179055905095945050505050565b6040516001600160a01b0380851660248301528316604482015260648101829052611e5d9085906323b872dd60e01b906084015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152612956565b50505050565b6001600160a01b03811660009081526003602052604090205460ff1615611ecc5760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f72000000000060448201526064016108ad565b6001600160a01b038116600081815260036020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b59101611027565b600154600160a01b900460ff16611f795760405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f742070617573656400000000000000000000000060448201526064016108ad565b6001805460ff60a01b191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b6001600160a01b03811660009081526002602052604090205460ff1661202e5760405162461bcd60e51b815260206004820152601560248201527f4163636f756e74206973206e6f7420706175736572000000000000000000000060448201526064016108ad565b6001600160a01b038116600081815260026020908152604091829020805460ff1916905590519182527fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e9101611027565b6001600160a01b03811660009081526002602052604090205460ff16156120e85760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c7265616479207061757365720000000000000060448201526064016108ad565b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89101611027565b600154600160a01b900460ff16156121895760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108ad565b6001805460ff60a01b1916600160a01b1790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258611fa93390565b604080516080810182526000808252602082018190529181018290526060810191909152600082815260086020908152604091829020825160808101845281546001600160a01b03908116825260018301541692810192909252600281015492820192909252600390910154606082018190526122835760405162461bcd60e51b815260206004820152601a60248201527f64656c61796564207472616e73666572206e6f7420657869737400000000000060448201526064016108ad565b600a548160600151612295919061336f565b42116122e35760405162461bcd60e51b815260206004820152601d60248201527f64656c61796564207472616e73666572207374696c6c206c6f636b656400000060448201526064016108ad565b600083815260086020908152604080832080546001600160a01b03199081168255600182018054909116905560028101849055600301929092558251908301518383015192517f3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d44269361237b93889390929091909384526001600160a01b03928316602085015291166040830152606082015260800190565b60405180910390a192915050565b600e546001600160a01b03908116908316036124a557600e54604051632e1a7d4d60e01b8152600481018390526001600160a01b0390911690632e1a7d4d90602401600060405180830381600087803b1580156123e557600080fd5b505af11580156123f9573d6000803e3d6000fd5b505050506000836001600160a01b03168261c35090604051600060405180830381858888f193505050503d806000811461244f576040519150601f19603f3d011682016040523d82523d6000602084013e612454565b606091505b5050905080611e5d5760405162461bcd60e51b815260206004820152601b60248201527f6661696c656420746f2073656e64206e617469766520746f6b656e000000000060448201526064016108ad565b6124b96001600160a01b0383168483612a3b565b505050565b6040805160c08101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905283518085019094528184528301849052909190805b602083015151835110156126125761251c83612a6b565b90925090508160010361254a5761253a61253584612aa5565b612b62565b6001600160a01b03168452612505565b816002036125715761255e61253584612aa5565b6001600160a01b03166020850152612505565b816003036125945761258a61258584612aa5565b612b73565b6040850152612505565b816004036125bb576125a861253584612aa5565b6001600160a01b03166060850152612505565b816005036125e0576125cc83612baa565b67ffffffffffffffff166080850152612505565b81600603612603576125f96125f484612aa5565b612c25565b60a0850152612505565b61260d8382612c3d565b612505565b505050919050565b600454600003612628575050565b6001600160a01b0382166000908152600660205260408120549081900361264e57505050565b6001600160a01b038316600090815260056020526040812054600454909142916126788184613382565b61268291906133a4565b6001600160a01b0387166000908152600760205260409020549091508111156126ad578492506126ba565b6126b7858461336f565b92505b8383111561270a5760405162461bcd60e51b815260206004820152601260248201527f766f6c756d65206578636565647320636170000000000000000000000000000060448201526064016108ad565b506001600160a01b039094166000908152600560209081526040808320939093556007905220929092555050565b600084815260086020526040902060030154156127975760405162461bcd60e51b815260206004820152601f60248201527f64656c61796564207472616e7366657220616c7265616479206578697374730060448201526064016108ad565b604080516080810182526001600160a01b0380861682528481166020808401918252838501868152426060860190815260008b8152600890935291869020945185549085166001600160a01b031991821617865592516001860180549190951693169290921790925551600283015551600390910155517fcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce69061283d9086815260200190565b60405180910390a150505050565b6001600160a01b03811660009081526003602052604090205460ff166128b35760405162461bcd60e51b815260206004820152601760248201527f4163636f756e74206973206e6f7420676f7665726e6f7200000000000000000060448201526064016108ad565b6001600160a01b038116600081815260036020908152604091829020805460ff1916905590519182527f1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b9101611027565b600180546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b60006129ab826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316612cad9092919063ffffffff16565b8051909150156124b957808060200190518101906129c991906133bb565b6124b95760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016108ad565b6040516001600160a01b0383166024820152604481018290526124b990849063a9059cbb60e01b90606401611df9565b6000806000612a7984612baa565b9050612a86600882613382565b9250806007166005811115612a9d57612a9d6133dd565b915050915091565b60606000612ab283612baa565b90506000818460000151612ac6919061336f565b9050836020015151811115612ada57600080fd5b8167ffffffffffffffff811115612af357612af36133f3565b6040519080825280601f01601f191660200182016040528015612b1d576020820181803683370190505b50602080860151865192955091818601919083010160005b85811015612b57578181015183820152612b5060208261336f565b9050612b35565b505050935250919050565b6000612b6d82612cc6565b92915050565b6000602082511115612b8457600080fd5b6020820151905081516020612b999190613409565b612ba49060086133a4565b1c919050565b602080820151825181019091015160009182805b600a81101561028f5783811a9150612bd78160076133a4565b82607f16901b8517945081608016600003612c1357612bf781600161336f565b86518790612c0690839061336f565b9052509395945050505050565b80612c1d81613155565b915050612bbe565b60008151602014612c3557600080fd5b506020015190565b6000816005811115612c5157612c516133dd565b03612c5f576124b982612baa565b6002816005811115612c7357612c736133dd565b0361028f576000612c8383612baa565b90508083600001818151612c97919061336f565b905250602083015151835111156124b957600080fd5b6060612cbc8484600085612cee565b90505b9392505050565b60008151601414612cd657600080fd5b50602001516c01000000000000000000000000900490565b606082471015612d665760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016108ad565b6001600160a01b0385163b612dbd5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016108ad565b600080866001600160a01b03168587604051612dd9919061341c565b60006040518083038185875af1925050503d8060008114612e16576040519150601f19603f3d011682016040523d82523d6000602084013e612e1b565b606091505b5091509150612e2b828286612e36565b979650505050505050565b60608315612e45575081612cbf565b825115612e555782518084602001fd5b8160405162461bcd60e51b81526004016108ad9190613438565b803567ffffffffffffffff81168114612e8757600080fd5b919050565b80356001600160a01b0381168114612e8757600080fd5b60008060008060808587031215612eb957600080fd5b84359350612ec960208601612e6f565b9250612ed760408601612e8c565b9150612ee560608601612e6f565b905092959194509250565b600060208284031215612f0257600080fd5b5035919050565b60008083601f840112612f1b57600080fd5b50813567ffffffffffffffff811115612f3357600080fd5b6020830191508360208260051b8501011115612f4e57600080fd5b9250929050565b60008060008060408587031215612f6b57600080fd5b843567ffffffffffffffff80821115612f8357600080fd5b612f8f88838901612f09565b90965094506020870135915080821115612fa857600080fd5b50612fb587828801612f09565b95989497509550505050565b600080600080600060a08688031215612fd957600080fd5b612fe286612e8c565b945060208601359350612ff760408701612e6f565b925061300560608701612e8c565b915061301360808701612e6f565b90509295509295909350565b60006020828403121561303157600080fd5b612cbf82612e8c565b6000806000806000806000806080898b03121561305657600080fd5b883567ffffffffffffffff8082111561306e57600080fd5b818b0191508b601f83011261308257600080fd5b81358181111561309157600080fd5b8c60208285010111156130a357600080fd5b60209283019a509850908a013590808211156130be57600080fd5b6130ca8c838d01612f09565b909850965060408b01359150808211156130e357600080fd5b6130ef8c838d01612f09565b909650945060608b013591508082111561310857600080fd5b506131158b828c01612f09565b999c989b5096995094979396929594505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016131675761316761313f565b5060010190565b838152818360208301376000910160200190815292915050565b60005b838110156131a357818101518382015260200161318b565b50506000910152565b600081518084526131c4816020860160208601613188565b601f01601f19169290920160200192915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b8183526000602080850194508260005b8581101561323d576001600160a01b0361322a83612e8c565b1687529582019590820190600101613211565b509495945050505050565b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83111561327a57600080fd5b8260051b80836020870137939093016020019392505050565b6080815260006132a6608083018a6131ac565b602083820381850152818983528183019050818a60051b8401018b60005b8c81101561333457858303601f190184528135368f9003601e190181126132ea57600080fd5b8e01858101903567ffffffffffffffff81111561330657600080fd5b80360382131561331557600080fd5b6133208582846131d8565b9587019594505050908401906001016132c4565b50508581036040870152613349818a8c613201565b93505050508281036060840152613361818587613248565b9a9950505050505050505050565b80820180821115612b6d57612b6d61313f565b60008261339f57634e487b7160e01b600052601260045260246000fd5b500490565b8082028115828204841417612b6d57612b6d61313f565b6000602082840312156133cd57600080fd5b81518015158114612cbf57600080fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b81810381811115612b6d57612b6d61313f565b6000825161342e818460208701613188565b9190910192915050565b602081526000612cbf60208301846131ac56fea26469706673582212207b9aaeea7360280588a1e06609b66cd53d37c1b24a1921ada7fa2264bcee4bb764736f6c63430008110033",
}

// OriginalTokenVaultABI is the input ABI used to generate the binding from.
// Deprecated: Use OriginalTokenVaultMetaData.ABI instead.
var OriginalTokenVaultABI = OriginalTokenVaultMetaData.ABI

// OriginalTokenVaultBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use OriginalTokenVaultMetaData.Bin instead.
var OriginalTokenVaultBin = OriginalTokenVaultMetaData.Bin

// DeployOriginalTokenVault deploys a new Ethereum contract, binding an instance of OriginalTokenVault to it.
func DeployOriginalTokenVault(auth *bind.TransactOpts, backend bind.ContractBackend, _sigsVerifier common.Address) (common.Address, *types.Transaction, *OriginalTokenVault, error) {
	parsed, err := OriginalTokenVaultMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(OriginalTokenVaultBin), backend, _sigsVerifier)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &OriginalTokenVault{OriginalTokenVaultCaller: OriginalTokenVaultCaller{contract: contract}, OriginalTokenVaultTransactor: OriginalTokenVaultTransactor{contract: contract}, OriginalTokenVaultFilterer: OriginalTokenVaultFilterer{contract: contract}}, nil
}

// OriginalTokenVault is an auto generated Go binding around an Ethereum contract.
type OriginalTokenVault struct {
	OriginalTokenVaultCaller     // Read-only binding to the contract
	OriginalTokenVaultTransactor // Write-only binding to the contract
	OriginalTokenVaultFilterer   // Log filterer for contract events
}

// OriginalTokenVaultCaller is an auto generated read-only Go binding around an Ethereum contract.
type OriginalTokenVaultCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OriginalTokenVaultTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OriginalTokenVaultTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OriginalTokenVaultFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OriginalTokenVaultFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OriginalTokenVaultSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OriginalTokenVaultSession struct {
	Contract     *OriginalTokenVault // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// OriginalTokenVaultCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OriginalTokenVaultCallerSession struct {
	Contract *OriginalTokenVaultCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// OriginalTokenVaultTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OriginalTokenVaultTransactorSession struct {
	Contract     *OriginalTokenVaultTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// OriginalTokenVaultRaw is an auto generated low-level Go binding around an Ethereum contract.
type OriginalTokenVaultRaw struct {
	Contract *OriginalTokenVault // Generic contract binding to access the raw methods on
}

// OriginalTokenVaultCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OriginalTokenVaultCallerRaw struct {
	Contract *OriginalTokenVaultCaller // Generic read-only contract binding to access the raw methods on
}

// OriginalTokenVaultTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OriginalTokenVaultTransactorRaw struct {
	Contract *OriginalTokenVaultTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOriginalTokenVault creates a new instance of OriginalTokenVault, bound to a specific deployed contract.
func NewOriginalTokenVault(address common.Address, backend bind.ContractBackend) (*OriginalTokenVault, error) {
	contract, err := bindOriginalTokenVault(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVault{OriginalTokenVaultCaller: OriginalTokenVaultCaller{contract: contract}, OriginalTokenVaultTransactor: OriginalTokenVaultTransactor{contract: contract}, OriginalTokenVaultFilterer: OriginalTokenVaultFilterer{contract: contract}}, nil
}

// NewOriginalTokenVaultCaller creates a new read-only instance of OriginalTokenVault, bound to a specific deployed contract.
func NewOriginalTokenVaultCaller(address common.Address, caller bind.ContractCaller) (*OriginalTokenVaultCaller, error) {
	contract, err := bindOriginalTokenVault(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultCaller{contract: contract}, nil
}

// NewOriginalTokenVaultTransactor creates a new write-only instance of OriginalTokenVault, bound to a specific deployed contract.
func NewOriginalTokenVaultTransactor(address common.Address, transactor bind.ContractTransactor) (*OriginalTokenVaultTransactor, error) {
	contract, err := bindOriginalTokenVault(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultTransactor{contract: contract}, nil
}

// NewOriginalTokenVaultFilterer creates a new log filterer instance of OriginalTokenVault, bound to a specific deployed contract.
func NewOriginalTokenVaultFilterer(address common.Address, filterer bind.ContractFilterer) (*OriginalTokenVaultFilterer, error) {
	contract, err := bindOriginalTokenVault(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultFilterer{contract: contract}, nil
}

// bindOriginalTokenVault binds a generic wrapper to an already deployed contract.
func bindOriginalTokenVault(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(OriginalTokenVaultABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_OriginalTokenVault *OriginalTokenVaultRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _OriginalTokenVault.Contract.OriginalTokenVaultCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_OriginalTokenVault *OriginalTokenVaultRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.OriginalTokenVaultTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_OriginalTokenVault *OriginalTokenVaultRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.OriginalTokenVaultTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_OriginalTokenVault *OriginalTokenVaultCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _OriginalTokenVault.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_OriginalTokenVault *OriginalTokenVaultTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_OriginalTokenVault *OriginalTokenVaultTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.contract.Transact(opts, method, params...)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) DelayPeriod(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "delayPeriod")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) DelayPeriod() (*big.Int, error) {
	return _OriginalTokenVault.Contract.DelayPeriod(&_OriginalTokenVault.CallOpts)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) DelayPeriod() (*big.Int, error) {
	return _OriginalTokenVault.Contract.DelayPeriod(&_OriginalTokenVault.CallOpts)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) DelayThresholds(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "delayThresholds", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.DelayThresholds(&_OriginalTokenVault.CallOpts, arg0)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.DelayThresholds(&_OriginalTokenVault.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_OriginalTokenVault *OriginalTokenVaultCaller) DelayedTransfers(opts *bind.CallOpts, arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "delayedTransfers", arg0)

	outstruct := new(struct {
		Receiver  common.Address
		Token     common.Address
		Amount    *big.Int
		Timestamp *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Receiver = *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	outstruct.Token = *abi.ConvertType(out[1], new(common.Address)).(*common.Address)
	outstruct.Amount = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.Timestamp = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_OriginalTokenVault *OriginalTokenVaultSession) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _OriginalTokenVault.Contract.DelayedTransfers(&_OriginalTokenVault.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _OriginalTokenVault.Contract.DelayedTransfers(&_OriginalTokenVault.CallOpts, arg0)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) EpochLength(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "epochLength")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) EpochLength() (*big.Int, error) {
	return _OriginalTokenVault.Contract.EpochLength(&_OriginalTokenVault.CallOpts)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) EpochLength() (*big.Int, error) {
	return _OriginalTokenVault.Contract.EpochLength(&_OriginalTokenVault.CallOpts)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) EpochVolumeCaps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "epochVolumeCaps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.EpochVolumeCaps(&_OriginalTokenVault.CallOpts, arg0)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.EpochVolumeCaps(&_OriginalTokenVault.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) EpochVolumes(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "epochVolumes", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.EpochVolumes(&_OriginalTokenVault.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.EpochVolumes(&_OriginalTokenVault.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCaller) Governors(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "governors", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultSession) Governors(arg0 common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.Governors(&_OriginalTokenVault.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) Governors(arg0 common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.Governors(&_OriginalTokenVault.CallOpts, arg0)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCaller) IsGovernor(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "isGovernor", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultSession) IsGovernor(_account common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.IsGovernor(&_OriginalTokenVault.CallOpts, _account)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) IsGovernor(_account common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.IsGovernor(&_OriginalTokenVault.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultSession) IsPauser(account common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.IsPauser(&_OriginalTokenVault.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) IsPauser(account common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.IsPauser(&_OriginalTokenVault.CallOpts, account)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) LastOpTimestamps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "lastOpTimestamps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.LastOpTimestamps(&_OriginalTokenVault.CallOpts, arg0)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.LastOpTimestamps(&_OriginalTokenVault.CallOpts, arg0)
}

// MaxDeposit is a free data retrieval call binding the contract method 0x402d267d.
//
// Solidity: function maxDeposit(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) MaxDeposit(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "maxDeposit", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxDeposit is a free data retrieval call binding the contract method 0x402d267d.
//
// Solidity: function maxDeposit(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) MaxDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.MaxDeposit(&_OriginalTokenVault.CallOpts, arg0)
}

// MaxDeposit is a free data retrieval call binding the contract method 0x402d267d.
//
// Solidity: function maxDeposit(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) MaxDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.MaxDeposit(&_OriginalTokenVault.CallOpts, arg0)
}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) MinDeposit(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "minDeposit", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) MinDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.MinDeposit(&_OriginalTokenVault.CallOpts, arg0)
}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) MinDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.MinDeposit(&_OriginalTokenVault.CallOpts, arg0)
}

// NativeWrap is a free data retrieval call binding the contract method 0x457bfa2f.
//
// Solidity: function nativeWrap() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultCaller) NativeWrap(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "nativeWrap")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// NativeWrap is a free data retrieval call binding the contract method 0x457bfa2f.
//
// Solidity: function nativeWrap() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultSession) NativeWrap() (common.Address, error) {
	return _OriginalTokenVault.Contract.NativeWrap(&_OriginalTokenVault.CallOpts)
}

// NativeWrap is a free data retrieval call binding the contract method 0x457bfa2f.
//
// Solidity: function nativeWrap() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) NativeWrap() (common.Address, error) {
	return _OriginalTokenVault.Contract.NativeWrap(&_OriginalTokenVault.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultSession) Owner() (common.Address, error) {
	return _OriginalTokenVault.Contract.Owner(&_OriginalTokenVault.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) Owner() (common.Address, error) {
	return _OriginalTokenVault.Contract.Owner(&_OriginalTokenVault.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultSession) Paused() (bool, error) {
	return _OriginalTokenVault.Contract.Paused(&_OriginalTokenVault.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) Paused() (bool, error) {
	return _OriginalTokenVault.Contract.Paused(&_OriginalTokenVault.CallOpts)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultSession) Pausers(arg0 common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.Pausers(&_OriginalTokenVault.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.Pausers(&_OriginalTokenVault.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCaller) Records(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "records", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultSession) Records(arg0 [32]byte) (bool, error) {
	return _OriginalTokenVault.Contract.Records(&_OriginalTokenVault.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) Records(arg0 [32]byte) (bool, error) {
	return _OriginalTokenVault.Contract.Records(&_OriginalTokenVault.CallOpts, arg0)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultCaller) SigsVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "sigsVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultSession) SigsVerifier() (common.Address, error) {
	return _OriginalTokenVault.Contract.SigsVerifier(&_OriginalTokenVault.CallOpts)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) SigsVerifier() (common.Address, error) {
	return _OriginalTokenVault.Contract.SigsVerifier(&_OriginalTokenVault.CallOpts)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) AddGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "addGovernor", _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.AddGovernor(&_OriginalTokenVault.TransactOpts, _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.AddGovernor(&_OriginalTokenVault.TransactOpts, _account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.AddPauser(&_OriginalTokenVault.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.AddPauser(&_OriginalTokenVault.TransactOpts, account)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) Deposit(opts *bind.TransactOpts, _token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "deposit", _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) Deposit(_token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Deposit(&_OriginalTokenVault.TransactOpts, _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) Deposit(_token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Deposit(&_OriginalTokenVault.TransactOpts, _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// DepositNative is a paid mutator transaction binding the contract method 0x00a95fd7.
//
// Solidity: function depositNative(uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) payable returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) DepositNative(opts *bind.TransactOpts, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "depositNative", _amount, _mintChainId, _mintAccount, _nonce)
}

// DepositNative is a paid mutator transaction binding the contract method 0x00a95fd7.
//
// Solidity: function depositNative(uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) payable returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) DepositNative(_amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.DepositNative(&_OriginalTokenVault.TransactOpts, _amount, _mintChainId, _mintAccount, _nonce)
}

// DepositNative is a paid mutator transaction binding the contract method 0x00a95fd7.
//
// Solidity: function depositNative(uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) payable returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) DepositNative(_amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.DepositNative(&_OriginalTokenVault.TransactOpts, _amount, _mintChainId, _mintAccount, _nonce)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) ExecuteDelayedTransfer(opts *bind.TransactOpts, id [32]byte) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "executeDelayedTransfer", id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.ExecuteDelayedTransfer(&_OriginalTokenVault.TransactOpts, id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.ExecuteDelayedTransfer(&_OriginalTokenVault.TransactOpts, id)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) Pause() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Pause(&_OriginalTokenVault.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) Pause() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Pause(&_OriginalTokenVault.TransactOpts)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) RemoveGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "removeGovernor", _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RemoveGovernor(&_OriginalTokenVault.TransactOpts, _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RemoveGovernor(&_OriginalTokenVault.TransactOpts, _account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RemovePauser(&_OriginalTokenVault.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RemovePauser(&_OriginalTokenVault.TransactOpts, account)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) RenounceGovernor(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "renounceGovernor")
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) RenounceGovernor() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RenounceGovernor(&_OriginalTokenVault.TransactOpts)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) RenounceGovernor() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RenounceGovernor(&_OriginalTokenVault.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) RenouncePauser() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RenouncePauser(&_OriginalTokenVault.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RenouncePauser(&_OriginalTokenVault.TransactOpts)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) SetDelayPeriod(opts *bind.TransactOpts, _period *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "setDelayPeriod", _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetDelayPeriod(&_OriginalTokenVault.TransactOpts, _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetDelayPeriod(&_OriginalTokenVault.TransactOpts, _period)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) SetDelayThresholds(opts *bind.TransactOpts, _tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "setDelayThresholds", _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetDelayThresholds(&_OriginalTokenVault.TransactOpts, _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetDelayThresholds(&_OriginalTokenVault.TransactOpts, _tokens, _thresholds)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) SetEpochLength(opts *bind.TransactOpts, _length *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "setEpochLength", _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetEpochLength(&_OriginalTokenVault.TransactOpts, _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetEpochLength(&_OriginalTokenVault.TransactOpts, _length)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) SetEpochVolumeCaps(opts *bind.TransactOpts, _tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "setEpochVolumeCaps", _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetEpochVolumeCaps(&_OriginalTokenVault.TransactOpts, _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetEpochVolumeCaps(&_OriginalTokenVault.TransactOpts, _tokens, _caps)
}

// SetMaxDeposit is a paid mutator transaction binding the contract method 0x303b6442.
//
// Solidity: function setMaxDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) SetMaxDeposit(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "setMaxDeposit", _tokens, _amounts)
}

// SetMaxDeposit is a paid mutator transaction binding the contract method 0x303b6442.
//
// Solidity: function setMaxDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) SetMaxDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetMaxDeposit(&_OriginalTokenVault.TransactOpts, _tokens, _amounts)
}

// SetMaxDeposit is a paid mutator transaction binding the contract method 0x303b6442.
//
// Solidity: function setMaxDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) SetMaxDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetMaxDeposit(&_OriginalTokenVault.TransactOpts, _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) SetMinDeposit(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "setMinDeposit", _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) SetMinDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetMinDeposit(&_OriginalTokenVault.TransactOpts, _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) SetMinDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetMinDeposit(&_OriginalTokenVault.TransactOpts, _tokens, _amounts)
}

// SetWrap is a paid mutator transaction binding the contract method 0x9ff9001a.
//
// Solidity: function setWrap(address _weth) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) SetWrap(opts *bind.TransactOpts, _weth common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "setWrap", _weth)
}

// SetWrap is a paid mutator transaction binding the contract method 0x9ff9001a.
//
// Solidity: function setWrap(address _weth) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) SetWrap(_weth common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetWrap(&_OriginalTokenVault.TransactOpts, _weth)
}

// SetWrap is a paid mutator transaction binding the contract method 0x9ff9001a.
//
// Solidity: function setWrap(address _weth) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) SetWrap(_weth common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetWrap(&_OriginalTokenVault.TransactOpts, _weth)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.TransferOwnership(&_OriginalTokenVault.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.TransferOwnership(&_OriginalTokenVault.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) Unpause() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Unpause(&_OriginalTokenVault.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) Unpause() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Unpause(&_OriginalTokenVault.TransactOpts)
}

// Withdraw is a paid mutator transaction binding the contract method 0xa21a9280.
//
// Solidity: function withdraw(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) Withdraw(opts *bind.TransactOpts, _request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "withdraw", _request, _sigs, _signers, _powers)
}

// Withdraw is a paid mutator transaction binding the contract method 0xa21a9280.
//
// Solidity: function withdraw(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) Withdraw(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Withdraw(&_OriginalTokenVault.TransactOpts, _request, _sigs, _signers, _powers)
}

// Withdraw is a paid mutator transaction binding the contract method 0xa21a9280.
//
// Solidity: function withdraw(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) Withdraw(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Withdraw(&_OriginalTokenVault.TransactOpts, _request, _sigs, _signers, _powers)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) Receive() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Receive(&_OriginalTokenVault.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) Receive() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Receive(&_OriginalTokenVault.TransactOpts)
}

// OriginalTokenVaultDelayPeriodUpdatedIterator is returned from FilterDelayPeriodUpdated and is used to iterate over the raw logs and unpacked data for DelayPeriodUpdated events raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayPeriodUpdatedIterator struct {
	Event *OriginalTokenVaultDelayPeriodUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultDelayPeriodUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultDelayPeriodUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultDelayPeriodUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultDelayPeriodUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultDelayPeriodUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultDelayPeriodUpdated represents a DelayPeriodUpdated event raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayPeriodUpdated struct {
	Period *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterDelayPeriodUpdated is a free log retrieval operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterDelayPeriodUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultDelayPeriodUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultDelayPeriodUpdatedIterator{contract: _OriginalTokenVault.contract, event: "DelayPeriodUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayPeriodUpdated is a free log subscription operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchDelayPeriodUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultDelayPeriodUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultDelayPeriodUpdated)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayPeriodUpdated is a log parse operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseDelayPeriodUpdated(log types.Log) (*OriginalTokenVaultDelayPeriodUpdated, error) {
	event := new(OriginalTokenVaultDelayPeriodUpdated)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultDelayThresholdUpdatedIterator is returned from FilterDelayThresholdUpdated and is used to iterate over the raw logs and unpacked data for DelayThresholdUpdated events raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayThresholdUpdatedIterator struct {
	Event *OriginalTokenVaultDelayThresholdUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultDelayThresholdUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultDelayThresholdUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultDelayThresholdUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultDelayThresholdUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultDelayThresholdUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultDelayThresholdUpdated represents a DelayThresholdUpdated event raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayThresholdUpdated struct {
	Token     common.Address
	Threshold *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterDelayThresholdUpdated is a free log retrieval operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterDelayThresholdUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultDelayThresholdUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultDelayThresholdUpdatedIterator{contract: _OriginalTokenVault.contract, event: "DelayThresholdUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayThresholdUpdated is a free log subscription operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchDelayThresholdUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultDelayThresholdUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultDelayThresholdUpdated)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayThresholdUpdated is a log parse operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseDelayThresholdUpdated(log types.Log) (*OriginalTokenVaultDelayThresholdUpdated, error) {
	event := new(OriginalTokenVaultDelayThresholdUpdated)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultDelayedTransferAddedIterator is returned from FilterDelayedTransferAdded and is used to iterate over the raw logs and unpacked data for DelayedTransferAdded events raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayedTransferAddedIterator struct {
	Event *OriginalTokenVaultDelayedTransferAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultDelayedTransferAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultDelayedTransferAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultDelayedTransferAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultDelayedTransferAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultDelayedTransferAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultDelayedTransferAdded represents a DelayedTransferAdded event raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayedTransferAdded struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferAdded is a free log retrieval operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterDelayedTransferAdded(opts *bind.FilterOpts) (*OriginalTokenVaultDelayedTransferAddedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultDelayedTransferAddedIterator{contract: _OriginalTokenVault.contract, event: "DelayedTransferAdded", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferAdded is a free log subscription operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchDelayedTransferAdded(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultDelayedTransferAdded) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultDelayedTransferAdded)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferAdded is a log parse operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseDelayedTransferAdded(log types.Log) (*OriginalTokenVaultDelayedTransferAdded, error) {
	event := new(OriginalTokenVaultDelayedTransferAdded)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultDelayedTransferExecutedIterator is returned from FilterDelayedTransferExecuted and is used to iterate over the raw logs and unpacked data for DelayedTransferExecuted events raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayedTransferExecutedIterator struct {
	Event *OriginalTokenVaultDelayedTransferExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultDelayedTransferExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultDelayedTransferExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultDelayedTransferExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultDelayedTransferExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultDelayedTransferExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultDelayedTransferExecuted represents a DelayedTransferExecuted event raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayedTransferExecuted struct {
	Id       [32]byte
	Receiver common.Address
	Token    common.Address
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferExecuted is a free log retrieval operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterDelayedTransferExecuted(opts *bind.FilterOpts) (*OriginalTokenVaultDelayedTransferExecutedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultDelayedTransferExecutedIterator{contract: _OriginalTokenVault.contract, event: "DelayedTransferExecuted", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferExecuted is a free log subscription operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchDelayedTransferExecuted(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultDelayedTransferExecuted) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultDelayedTransferExecuted)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferExecuted is a log parse operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseDelayedTransferExecuted(log types.Log) (*OriginalTokenVaultDelayedTransferExecuted, error) {
	event := new(OriginalTokenVaultDelayedTransferExecuted)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultDepositedIterator is returned from FilterDeposited and is used to iterate over the raw logs and unpacked data for Deposited events raised by the OriginalTokenVault contract.
type OriginalTokenVaultDepositedIterator struct {
	Event *OriginalTokenVaultDeposited // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultDepositedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultDeposited)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultDeposited)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultDepositedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultDepositedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultDeposited represents a Deposited event raised by the OriginalTokenVault contract.
type OriginalTokenVaultDeposited struct {
	DepositId   [32]byte
	Depositor   common.Address
	Token       common.Address
	Amount      *big.Int
	MintChainId uint64
	MintAccount common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterDeposited is a free log retrieval operation binding the contract event 0x15d2eeefbe4963b5b2178f239ddcc730dda55f1c23c22efb79ded0eb854ac789.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, uint64 mintChainId, address mintAccount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterDeposited(opts *bind.FilterOpts) (*OriginalTokenVaultDepositedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "Deposited")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultDepositedIterator{contract: _OriginalTokenVault.contract, event: "Deposited", logs: logs, sub: sub}, nil
}

// WatchDeposited is a free log subscription operation binding the contract event 0x15d2eeefbe4963b5b2178f239ddcc730dda55f1c23c22efb79ded0eb854ac789.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, uint64 mintChainId, address mintAccount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchDeposited(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultDeposited) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "Deposited")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultDeposited)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "Deposited", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDeposited is a log parse operation binding the contract event 0x15d2eeefbe4963b5b2178f239ddcc730dda55f1c23c22efb79ded0eb854ac789.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, uint64 mintChainId, address mintAccount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseDeposited(log types.Log) (*OriginalTokenVaultDeposited, error) {
	event := new(OriginalTokenVaultDeposited)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "Deposited", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultEpochLengthUpdatedIterator is returned from FilterEpochLengthUpdated and is used to iterate over the raw logs and unpacked data for EpochLengthUpdated events raised by the OriginalTokenVault contract.
type OriginalTokenVaultEpochLengthUpdatedIterator struct {
	Event *OriginalTokenVaultEpochLengthUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultEpochLengthUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultEpochLengthUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultEpochLengthUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultEpochLengthUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultEpochLengthUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultEpochLengthUpdated represents a EpochLengthUpdated event raised by the OriginalTokenVault contract.
type OriginalTokenVaultEpochLengthUpdated struct {
	Length *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterEpochLengthUpdated is a free log retrieval operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterEpochLengthUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultEpochLengthUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultEpochLengthUpdatedIterator{contract: _OriginalTokenVault.contract, event: "EpochLengthUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochLengthUpdated is a free log subscription operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchEpochLengthUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultEpochLengthUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultEpochLengthUpdated)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochLengthUpdated is a log parse operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseEpochLengthUpdated(log types.Log) (*OriginalTokenVaultEpochLengthUpdated, error) {
	event := new(OriginalTokenVaultEpochLengthUpdated)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultEpochVolumeUpdatedIterator is returned from FilterEpochVolumeUpdated and is used to iterate over the raw logs and unpacked data for EpochVolumeUpdated events raised by the OriginalTokenVault contract.
type OriginalTokenVaultEpochVolumeUpdatedIterator struct {
	Event *OriginalTokenVaultEpochVolumeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultEpochVolumeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultEpochVolumeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultEpochVolumeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultEpochVolumeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultEpochVolumeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultEpochVolumeUpdated represents a EpochVolumeUpdated event raised by the OriginalTokenVault contract.
type OriginalTokenVaultEpochVolumeUpdated struct {
	Token common.Address
	Cap   *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterEpochVolumeUpdated is a free log retrieval operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterEpochVolumeUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultEpochVolumeUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultEpochVolumeUpdatedIterator{contract: _OriginalTokenVault.contract, event: "EpochVolumeUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochVolumeUpdated is a free log subscription operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchEpochVolumeUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultEpochVolumeUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultEpochVolumeUpdated)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochVolumeUpdated is a log parse operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseEpochVolumeUpdated(log types.Log) (*OriginalTokenVaultEpochVolumeUpdated, error) {
	event := new(OriginalTokenVaultEpochVolumeUpdated)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultGovernorAddedIterator is returned from FilterGovernorAdded and is used to iterate over the raw logs and unpacked data for GovernorAdded events raised by the OriginalTokenVault contract.
type OriginalTokenVaultGovernorAddedIterator struct {
	Event *OriginalTokenVaultGovernorAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultGovernorAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultGovernorAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultGovernorAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultGovernorAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultGovernorAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultGovernorAdded represents a GovernorAdded event raised by the OriginalTokenVault contract.
type OriginalTokenVaultGovernorAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorAdded is a free log retrieval operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterGovernorAdded(opts *bind.FilterOpts) (*OriginalTokenVaultGovernorAddedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultGovernorAddedIterator{contract: _OriginalTokenVault.contract, event: "GovernorAdded", logs: logs, sub: sub}, nil
}

// WatchGovernorAdded is a free log subscription operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchGovernorAdded(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultGovernorAdded) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultGovernorAdded)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorAdded is a log parse operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseGovernorAdded(log types.Log) (*OriginalTokenVaultGovernorAdded, error) {
	event := new(OriginalTokenVaultGovernorAdded)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultGovernorRemovedIterator is returned from FilterGovernorRemoved and is used to iterate over the raw logs and unpacked data for GovernorRemoved events raised by the OriginalTokenVault contract.
type OriginalTokenVaultGovernorRemovedIterator struct {
	Event *OriginalTokenVaultGovernorRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultGovernorRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultGovernorRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultGovernorRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultGovernorRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultGovernorRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultGovernorRemoved represents a GovernorRemoved event raised by the OriginalTokenVault contract.
type OriginalTokenVaultGovernorRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorRemoved is a free log retrieval operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterGovernorRemoved(opts *bind.FilterOpts) (*OriginalTokenVaultGovernorRemovedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultGovernorRemovedIterator{contract: _OriginalTokenVault.contract, event: "GovernorRemoved", logs: logs, sub: sub}, nil
}

// WatchGovernorRemoved is a free log subscription operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchGovernorRemoved(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultGovernorRemoved) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultGovernorRemoved)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorRemoved is a log parse operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseGovernorRemoved(log types.Log) (*OriginalTokenVaultGovernorRemoved, error) {
	event := new(OriginalTokenVaultGovernorRemoved)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultMaxDepositUpdatedIterator is returned from FilterMaxDepositUpdated and is used to iterate over the raw logs and unpacked data for MaxDepositUpdated events raised by the OriginalTokenVault contract.
type OriginalTokenVaultMaxDepositUpdatedIterator struct {
	Event *OriginalTokenVaultMaxDepositUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultMaxDepositUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultMaxDepositUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultMaxDepositUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultMaxDepositUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultMaxDepositUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultMaxDepositUpdated represents a MaxDepositUpdated event raised by the OriginalTokenVault contract.
type OriginalTokenVaultMaxDepositUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMaxDepositUpdated is a free log retrieval operation binding the contract event 0x0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72.
//
// Solidity: event MaxDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterMaxDepositUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultMaxDepositUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "MaxDepositUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultMaxDepositUpdatedIterator{contract: _OriginalTokenVault.contract, event: "MaxDepositUpdated", logs: logs, sub: sub}, nil
}

// WatchMaxDepositUpdated is a free log subscription operation binding the contract event 0x0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72.
//
// Solidity: event MaxDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchMaxDepositUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultMaxDepositUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "MaxDepositUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultMaxDepositUpdated)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "MaxDepositUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMaxDepositUpdated is a log parse operation binding the contract event 0x0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72.
//
// Solidity: event MaxDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseMaxDepositUpdated(log types.Log) (*OriginalTokenVaultMaxDepositUpdated, error) {
	event := new(OriginalTokenVaultMaxDepositUpdated)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "MaxDepositUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultMinDepositUpdatedIterator is returned from FilterMinDepositUpdated and is used to iterate over the raw logs and unpacked data for MinDepositUpdated events raised by the OriginalTokenVault contract.
type OriginalTokenVaultMinDepositUpdatedIterator struct {
	Event *OriginalTokenVaultMinDepositUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultMinDepositUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultMinDepositUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultMinDepositUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultMinDepositUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultMinDepositUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultMinDepositUpdated represents a MinDepositUpdated event raised by the OriginalTokenVault contract.
type OriginalTokenVaultMinDepositUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMinDepositUpdated is a free log retrieval operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterMinDepositUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultMinDepositUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "MinDepositUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultMinDepositUpdatedIterator{contract: _OriginalTokenVault.contract, event: "MinDepositUpdated", logs: logs, sub: sub}, nil
}

// WatchMinDepositUpdated is a free log subscription operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchMinDepositUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultMinDepositUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "MinDepositUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultMinDepositUpdated)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "MinDepositUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinDepositUpdated is a log parse operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseMinDepositUpdated(log types.Log) (*OriginalTokenVaultMinDepositUpdated, error) {
	event := new(OriginalTokenVaultMinDepositUpdated)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "MinDepositUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the OriginalTokenVault contract.
type OriginalTokenVaultOwnershipTransferredIterator struct {
	Event *OriginalTokenVaultOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultOwnershipTransferred represents a OwnershipTransferred event raised by the OriginalTokenVault contract.
type OriginalTokenVaultOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*OriginalTokenVaultOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultOwnershipTransferredIterator{contract: _OriginalTokenVault.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultOwnershipTransferred)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseOwnershipTransferred(log types.Log) (*OriginalTokenVaultOwnershipTransferred, error) {
	event := new(OriginalTokenVaultOwnershipTransferred)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the OriginalTokenVault contract.
type OriginalTokenVaultPausedIterator struct {
	Event *OriginalTokenVaultPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultPaused represents a Paused event raised by the OriginalTokenVault contract.
type OriginalTokenVaultPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterPaused(opts *bind.FilterOpts) (*OriginalTokenVaultPausedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultPausedIterator{contract: _OriginalTokenVault.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultPaused) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultPaused)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParsePaused(log types.Log) (*OriginalTokenVaultPaused, error) {
	event := new(OriginalTokenVaultPaused)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the OriginalTokenVault contract.
type OriginalTokenVaultPauserAddedIterator struct {
	Event *OriginalTokenVaultPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultPauserAdded represents a PauserAdded event raised by the OriginalTokenVault contract.
type OriginalTokenVaultPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*OriginalTokenVaultPauserAddedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultPauserAddedIterator{contract: _OriginalTokenVault.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultPauserAdded) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultPauserAdded)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParsePauserAdded(log types.Log) (*OriginalTokenVaultPauserAdded, error) {
	event := new(OriginalTokenVaultPauserAdded)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the OriginalTokenVault contract.
type OriginalTokenVaultPauserRemovedIterator struct {
	Event *OriginalTokenVaultPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultPauserRemoved represents a PauserRemoved event raised by the OriginalTokenVault contract.
type OriginalTokenVaultPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*OriginalTokenVaultPauserRemovedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultPauserRemovedIterator{contract: _OriginalTokenVault.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultPauserRemoved)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParsePauserRemoved(log types.Log) (*OriginalTokenVaultPauserRemoved, error) {
	event := new(OriginalTokenVaultPauserRemoved)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the OriginalTokenVault contract.
type OriginalTokenVaultUnpausedIterator struct {
	Event *OriginalTokenVaultUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultUnpaused represents a Unpaused event raised by the OriginalTokenVault contract.
type OriginalTokenVaultUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterUnpaused(opts *bind.FilterOpts) (*OriginalTokenVaultUnpausedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultUnpausedIterator{contract: _OriginalTokenVault.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultUnpaused) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultUnpaused)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseUnpaused(log types.Log) (*OriginalTokenVaultUnpaused, error) {
	event := new(OriginalTokenVaultUnpaused)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultWithdrawnIterator is returned from FilterWithdrawn and is used to iterate over the raw logs and unpacked data for Withdrawn events raised by the OriginalTokenVault contract.
type OriginalTokenVaultWithdrawnIterator struct {
	Event *OriginalTokenVaultWithdrawn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultWithdrawnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultWithdrawn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultWithdrawn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultWithdrawnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultWithdrawnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultWithdrawn represents a Withdrawn event raised by the OriginalTokenVault contract.
type OriginalTokenVaultWithdrawn struct {
	WithdrawId  [32]byte
	Receiver    common.Address
	Token       common.Address
	Amount      *big.Int
	RefChainId  uint64
	RefId       [32]byte
	BurnAccount common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterWithdrawn is a free log retrieval operation binding the contract event 0x296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, uint64 refChainId, bytes32 refId, address burnAccount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterWithdrawn(opts *bind.FilterOpts) (*OriginalTokenVaultWithdrawnIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "Withdrawn")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultWithdrawnIterator{contract: _OriginalTokenVault.contract, event: "Withdrawn", logs: logs, sub: sub}, nil
}

// WatchWithdrawn is a free log subscription operation binding the contract event 0x296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, uint64 refChainId, bytes32 refId, address burnAccount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchWithdrawn(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultWithdrawn) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "Withdrawn")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultWithdrawn)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "Withdrawn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawn is a log parse operation binding the contract event 0x296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, uint64 refChainId, bytes32 refId, address burnAccount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseWithdrawn(log types.Log) (*OriginalTokenVaultWithdrawn, error) {
	event := new(OriginalTokenVaultWithdrawn)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "Withdrawn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeMetaData contains all meta data concerning the PeggedTokenBridge contract.
var PeggedTokenBridgeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"_sigsVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"burnId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawAccount\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"DelayPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"DelayThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"DelayedTransferAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DelayedTransferExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"EpochLengthUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"EpochVolumeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxBurnUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MinBurnUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"mintId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"refChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_withdrawAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delayThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"delayedTransfers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumeCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"executeDelayedTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"governors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastOpTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_request\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setDelayPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_thresholds\",\"type\":\"uint256[]\"}],\"name\":\"setDelayThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"setEpochLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_caps\",\"type\":\"uint256[]\"}],\"name\":\"setEpochVolumeCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMaxBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sigsVerifier\",\"outputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a06040523480156200001157600080fd5b5060405162002d2938038062002d2983398101604081905262000034916200024f565b6200003f3362000074565b6000805460ff60a01b191690556200005733620000c4565b62000062336200018f565b6001600160a01b031660805262000281565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b03811660009081526001602052604090205460ff1615620001335760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c7265616479207061757365720000000000000060448201526064015b60405180910390fd5b6001600160a01b038116600081815260016020818152604092839020805460ff191690921790915590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f891015b60405180910390a150565b6001600160a01b03811660009081526002602052604090205460ff1615620001fa5760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f72000000000060448201526064016200012a565b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5910162000184565b6000602082840312156200026257600080fd5b81516001600160a01b03811681146200027a57600080fd5b9392505050565b608051612a85620002a4600039600081816104fb01526113da0152612a856000f3fe608060405234801561001057600080fd5b50600436106102415760003560e01c806382dc1ec411610145578063de790c7e116100bd578063eecdac881161008c578063f832138311610071578063f8321383146105ad578063f8734302146105cd578063f9a8ea08146105e057600080fd5b8063eecdac8814610587578063f2fde38b1461059a57600080fd5b8063de790c7e1461051d578063e026049c14610530578063e3eece2614610538578063e43581b81461055b57600080fd5b8063adc0d57f11610114578063b5f2bc47116100f9578063b5f2bc47146104c3578063bf4816f0146104e3578063ccf2683b146104f657600080fd5b8063adc0d57f1461044d578063b1c94d94146104ba57600080fd5b806382dc1ec4146103fa5780638456cb591461040d5780638da5cb5b146104155780639e25fc5c1461043a57600080fd5b806352532faa116101d857806360216b00116101a75780636ef8d66d1161018c5780636ef8d66d146103af5780637f856013146103b757806380f51c12146103d757600080fd5b806360216b001461037c5780636b2c0f551461039c57600080fd5b806352532faa1461032e57806354eea7961461034e57806357d775f8146103615780635c975abb1461036a57600080fd5b80633f4ba83a116102145780633f4ba83a146102b957806346fbf68e146102c157806347b16c6c146102ed578063497bf3b21461030057600080fd5b806301e647251461024657806317bdbae51461027e5780633c4a25d0146102935780633d572107146102a6575b600080fd5b610269610254366004612529565b600a6020526000908152604090205460ff1681565b60405190151581526020015b60405180910390f35b61029161028c36600461258e565b6105f3565b005b6102916102a1366004612616565b610796565b6102916102b4366004612529565b61080b565b61029161089f565b6102696102cf366004612616565b6001600160a01b031660009081526001602052604090205460ff1690565b6102916102fb36600461258e565b610908565b61032061030e366004612616565b600c6020526000908152604090205481565b604051908152602001610275565b61032061033c366004612616565b60086020526000908152604090205481565b61029161035c366004612529565b610a9f565b61032060035481565b600054600160a01b900460ff16610269565b61032061038a366004612616565b60046020526000908152604090205481565b6102916103aa366004612616565b610b2c565b610291610b9e565b6103206103c5366004612616565b600b6020526000908152604090205481565b6102696103e5366004612616565b60016020526000908152604090205460ff1681565b610291610408366004612616565b610ba7565b610291610c19565b6000546001600160a01b03165b6040516001600160a01b039091168152602001610275565b610291610448366004612529565b610c80565b61048f61045b366004612529565b60076020526000908152604090208054600182015460028301546003909301546001600160a01b0392831693919092169184565b604080516001600160a01b039586168152949093166020850152918301526060820152608001610275565b61032060095481565b6103206104d1366004612616565b60056020526000908152604090205481565b6102916104f136600461258e565b610d4d565b6104227f000000000000000000000000000000000000000000000000000000000000000081565b61029161052b366004612638565b610ee4565b6102916111cd565b610269610546366004612616565b60026020526000908152604090205460ff1681565b610269610569366004612616565b6001600160a01b031660009081526002602052604090205460ff1690565b610291610595366004612616565b6111d6565b6102916105a8366004612616565b611248565b6103206105bb366004612616565b60066020526000908152604090205481565b6102916105db366004612694565b611336565b6102916105ee36600461258e565b61173f565b3360009081526002602052604090205460ff166106505760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064015b60405180910390fd5b8281146106915760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b6044820152606401610647565b60005b8381101561078f578282828181106106ae576106ae612783565b90506020020135600860008787858181106106cb576106cb612783565b90506020020160208101906106e09190612616565b6001600160a01b031681526020810191909152604001600020557fceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce85858381811061072d5761072d612783565b90506020020160208101906107429190612616565b84848481811061075457610754612783565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610787816127af565b915050610694565b5050505050565b336107a96000546001600160a01b031690565b6001600160a01b0316146107ff5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610647565b610808816118d6565b50565b3360009081526002602052604090205460ff166108635760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b6044820152606401610647565b60098190556040518181527fc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6906020015b60405180910390a150565b3360009081526001602052604090205460ff166108fe5760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606401610647565b610906611993565b565b3360009081526002602052604090205460ff166109605760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b6044820152606401610647565b8281146109a15760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b6044820152606401610647565b60005b8381101561078f578282828181106109be576109be612783565b90506020020135600560008787858181106109db576109db612783565b90506020020160208101906109f09190612616565b6001600160a01b031681526020810191909152604001600020557f608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89858583818110610a3d57610a3d612783565b9050602002016020810190610a529190612616565b848484818110610a6457610a64612783565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610a97816127af565b9150506109a4565b3360009081526002602052604090205460ff16610af75760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b6044820152606401610647565b60038190556040518181527f2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b390602001610894565b33610b3f6000546001600160a01b031690565b6001600160a01b031614610b955760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610647565b61080881611a39565b61090633611a39565b33610bba6000546001600160a01b031690565b6001600160a01b031614610c105760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610647565b61080881611af2565b3360009081526001602052604090205460ff16610c785760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606401610647565b610906611bb0565b600054600160a01b900460ff1615610ccd5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b6044820152606401610647565b6000610cd882611c38565b6020810151815160408084015190516340c10f1960e01b81526001600160a01b039283166004820152602481019190915292935016906340c10f1990604401600060405180830381600087803b158015610d3157600080fd5b505af1158015610d45573d6000803e3d6000fd5b505050505050565b3360009081526002602052604090205460ff16610da55760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b6044820152606401610647565b828114610de65760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b6044820152606401610647565b60005b8381101561078f57828282818110610e0357610e03612783565b90506020020135600b6000878785818110610e2057610e20612783565b9050602002016020810190610e359190612616565b6001600160a01b031681526020810191909152604001600020557f3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683858583818110610e8257610e82612783565b9050602002016020810190610e979190612616565b848484818110610ea957610ea9612783565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610edc816127af565b915050610de9565b600054600160a01b900460ff1615610f315760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b6044820152606401610647565b6001600160a01b0384166000908152600b60205260409020548311610f985760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f20736d616c6c000000000000000000000000000000006044820152606401610647565b6001600160a01b0384166000908152600c60205260409020541580610fd557506001600160a01b0384166000908152600c60205260409020548311155b6110215760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f206c61726765000000000000000000000000000000006044820152606401610647565b6040516bffffffffffffffffffffffff1933606090811b8216602084015286811b821660348401526048830186905284901b16606882015277ffffffffffffffffffffffffffffffffffffffffffffffff1960c083811b8216607c84015246901b166084820152600090608c0160408051601f1981840301815291815281516020928301206000818152600a90935291205490915060ff16156110f65760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b6044820152606401610647565b6000818152600a602052604090819020805460ff1916600117905551632770a7eb60e21b8152336004820152602481018590526001600160a01b03861690639dc29fac90604401600060405180830381600087803b15801561115757600080fd5b505af115801561116b573d6000803e3d6000fd5b5050604080518481526001600160a01b0389811660208301523382840152606082018990528716608082015290517f75f1bf55bb1de41b63a775dc7d4500f01114ee62b688a6b11d34f4692c1f3d4393509081900360a0019150a15050505050565b61090633611e0a565b336111e96000546001600160a01b031690565b6001600160a01b03161461123f5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610647565b61080881611e0a565b3361125b6000546001600160a01b031690565b6001600160a01b0316146112b15760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610647565b6001600160a01b03811661132d5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608401610647565b61080881611ec3565b600054600160a01b900460ff16156113835760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b6044820152606401610647565b600046306040516020016113c092919091825260601b6bffffffffffffffffffffffff1916602082015263135a5b9d60e21b603482015260380190565b6040516020818303038152906040528051906020012090507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663682dbc22828b8b60405160200161141c939291906127c8565b6040516020818303038152906040528989898989896040518863ffffffff1660e01b8152600401611453979695949392919061292f565b60006040518083038186803b15801561146b57600080fd5b505afa15801561147f573d6000803e3d6000fd5b5050505060006114c48a8a8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611f2092505050565b6020818101518251604080850151606080870151608088015160a0890151855197841b6bffffffffffffffffffffffff19908116898b015296841b871660348901526048880194909452911b909316606885015260c09290921b77ffffffffffffffffffffffffffffffffffffffffffffffff1916607c8401526084808401929092528051808403909201825260a490920182528051908301206000818152600a9093529120549192509060ff16156115af5760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b6044820152606401610647565b6000818152600a602052604090819020805460ff191660011790558251908301516115da919061207c565b81516001600160a01b031660009081526008602052604090205480158015906116065750808360400151115b15611628576116238284602001518560000151866040015161219a565b611698565b8251602084015160408086015190516340c10f1960e01b81526001600160a01b03928316600482015260248101919091529116906340c10f1990604401600060405180830381600087803b15801561167f57600080fd5b505af1158015611693573d6000803e3d6000fd5b505050505b7f5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a8284600001518560200151866040015187608001518860a00151896060015160405161172997969594939291909687526001600160a01b0395861660208801529385166040870152606086019290925267ffffffffffffffff16608085015260a08401521660c082015260e00190565b60405180910390a1505050505050505050505050565b3360009081526002602052604090205460ff166117975760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b6044820152606401610647565b8281146117d85760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b6044820152606401610647565b60005b8381101561078f578282828181106117f5576117f5612783565b90506020020135600c600087878581811061181257611812612783565b90506020020160208101906118279190612616565b6001600160a01b031681526020810191909152604001600020557fa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da585858381811061187457611874612783565b90506020020160208101906118899190612616565b84848481811061189b5761189b612783565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a1806118ce816127af565b9150506117db565b6001600160a01b03811660009081526002602052604090205460ff161561193f5760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f7200000000006044820152606401610647565b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b59101610894565b600054600160a01b900460ff166119ec5760405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606401610647565b6000805460ff60a01b191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b6001600160a01b03811660009081526001602052604090205460ff16611aa15760405162461bcd60e51b815260206004820152601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606401610647565b6001600160a01b038116600081815260016020908152604091829020805460ff1916905590519182527fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e9101610894565b6001600160a01b03811660009081526001602052604090205460ff1615611b5b5760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606401610647565b6001600160a01b038116600081815260016020818152604092839020805460ff191690921790915590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89101610894565b600054600160a01b900460ff1615611bfd5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b6044820152606401610647565b6000805460ff60a01b1916600160a01b1790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258611a1c3390565b604080516080810182526000808252602082018190529181018290526060810191909152600082815260076020908152604091829020825160808101845281546001600160a01b0390811682526001830154169281019290925260028101549282019290925260039091015460608201819052611cf75760405162461bcd60e51b815260206004820152601a60248201527f64656c61796564207472616e73666572206e6f742065786973740000000000006044820152606401610647565b6009548160600151611d0991906129c4565b4211611d575760405162461bcd60e51b815260206004820152601d60248201527f64656c61796564207472616e73666572207374696c6c206c6f636b65640000006044820152606401610647565b6000838152600760209081526040808320805473ffffffffffffffffffffffffffffffffffffffff199081168255600182018054909116905560028101849055600301929092558251908301518383015192517f3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d442693611dfc93889390929091909384526001600160a01b03928316602085015291166040830152606082015260800190565b60405180910390a192915050565b6001600160a01b03811660009081526002602052604090205460ff16611e725760405162461bcd60e51b815260206004820152601760248201527f4163636f756e74206973206e6f7420676f7665726e6f720000000000000000006044820152606401610647565b6001600160a01b038116600081815260026020908152604091829020805460ff1916905590519182527f1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b9101610894565b600080546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6040805160c08101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905283518085019094528184528301849052909190805b6020830151518351101561207457611f7e836122ba565b909250905081600103611fac57611f9c611f97846122f4565b6123b1565b6001600160a01b03168452611f67565b81600203611fd357611fc0611f97846122f4565b6001600160a01b03166020850152611f67565b81600303611ff657611fec611fe7846122f4565b6123c2565b6040850152611f67565b8160040361201d5761200a611f97846122f4565b6001600160a01b03166060850152611f67565b816005036120425761202e836123f9565b67ffffffffffffffff166080850152611f67565b816006036120655761205b612056846122f4565b612474565b60a0850152611f67565b61206f838261248c565b611f67565b505050919050565b60035460000361208a575050565b6001600160a01b038216600090815260056020526040812054908190036120b057505050565b6001600160a01b038316600090815260046020526040812054600354909142916120da81846129d7565b6120e491906129f9565b6001600160a01b03871660009081526006602052604090205490915081111561210f5784925061211c565b61211985846129c4565b92505b8383111561216c5760405162461bcd60e51b815260206004820152601260248201527f766f6c756d6520657863656564732063617000000000000000000000000000006044820152606401610647565b506001600160a01b039094166000908152600460209081526040808320939093556006905220929092555050565b600084815260076020526040902060030154156121f95760405162461bcd60e51b815260206004820152601f60248201527f64656c61796564207472616e7366657220616c726561647920657869737473006044820152606401610647565b604080516080810182526001600160a01b0380861682528481166020808401918252838501868152426060860190815260008b81526007909352918690209451855490851673ffffffffffffffffffffffffffffffffffffffff1991821617865592516001860180549190951693169290921790925551600283015551600390910155517fcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6906122ac9086815260200190565b60405180910390a150505050565b60008060006122c8846123f9565b90506122d56008826129d7565b92508060071660058111156122ec576122ec612a10565b915050915091565b60606000612301836123f9565b9050600081846000015161231591906129c4565b905083602001515181111561232957600080fd5b8167ffffffffffffffff81111561234257612342612a26565b6040519080825280601f01601f19166020018201604052801561236c576020820181803683370190505b50602080860151865192955091818601919083010160005b858110156123a657818101518382015261239f6020826129c4565b9050612384565b505050935250919050565b60006123bc82612501565b92915050565b60006020825111156123d357600080fd5b60208201519050815160206123e89190612a3c565b6123f39060086129f9565b1c919050565b602080820151825181019091015160009182805b600a8110156102415783811a91506124268160076129f9565b82607f16901b8517945081608016600003612462576124468160016129c4565b865187906124559083906129c4565b9052509395945050505050565b8061246c816127af565b91505061240d565b6000815160201461248457600080fd5b506020015190565b60008160058111156124a0576124a0612a10565b036124b3576124ae826123f9565b505050565b60028160058111156124c7576124c7612a10565b036102415760006124d7836123f9565b905080836000018181516124eb91906129c4565b905250602083015151835111156124ae57600080fd5b6000815160141461251157600080fd5b50602001516c01000000000000000000000000900490565b60006020828403121561253b57600080fd5b5035919050565b60008083601f84011261255457600080fd5b50813567ffffffffffffffff81111561256c57600080fd5b6020830191508360208260051b850101111561258757600080fd5b9250929050565b600080600080604085870312156125a457600080fd5b843567ffffffffffffffff808211156125bc57600080fd5b6125c888838901612542565b909650945060208701359150808211156125e157600080fd5b506125ee87828801612542565b95989497509550505050565b80356001600160a01b038116811461261157600080fd5b919050565b60006020828403121561262857600080fd5b612631826125fa565b9392505050565b6000806000806080858703121561264e57600080fd5b612657856125fa565b93506020850135925061266c604086016125fa565b9150606085013567ffffffffffffffff8116811461268957600080fd5b939692955090935050565b6000806000806000806000806080898b0312156126b057600080fd5b883567ffffffffffffffff808211156126c857600080fd5b818b0191508b601f8301126126dc57600080fd5b8135818111156126eb57600080fd5b8c60208285010111156126fd57600080fd5b60209283019a509850908a0135908082111561271857600080fd5b6127248c838d01612542565b909850965060408b013591508082111561273d57600080fd5b6127498c838d01612542565b909650945060608b013591508082111561276257600080fd5b5061276f8b828c01612542565b999c989b5096995094979396929594505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016127c1576127c1612799565b5060010190565b838152818360208301376000910160200190815292915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b81835260006020808501808196508560051b810191508460005b878110156128905782840389528135601e1988360301811261284657600080fd5b8701858101903567ffffffffffffffff81111561286257600080fd5b80360382131561287157600080fd5b61287c8682846127e2565b9a87019a9550505090840190600101612825565b5091979650505050505050565b8183526000602080850194508260005b858110156128d9576001600160a01b036128c6836125fa565b16875295820195908201906001016128ad565b509495945050505050565b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83111561291657600080fd5b8260051b80836020870137939093016020019392505050565b608081526000885180608084015260005b8181101561295d576020818c0181015160a0868401015201612940565b50600060a08285010152601f19601f8201168301905060a083820301602084015261298c60a08201898b61280b565b905082810360408401526129a181878961289d565b905082810360608401526129b68185876128e4565b9a9950505050505050505050565b808201808211156123bc576123bc612799565b6000826129f457634e487b7160e01b600052601260045260246000fd5b500490565b80820281158282048414176123bc576123bc612799565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b818103818111156123bc576123bc61279956fea2646970667358221220cd8111fbcdc77099ca5fc3460e5e27c466954953fcb16d62f5ff78779821afaa64736f6c63430008110033",
}

// PeggedTokenBridgeABI is the input ABI used to generate the binding from.
// Deprecated: Use PeggedTokenBridgeMetaData.ABI instead.
var PeggedTokenBridgeABI = PeggedTokenBridgeMetaData.ABI

// PeggedTokenBridgeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PeggedTokenBridgeMetaData.Bin instead.
var PeggedTokenBridgeBin = PeggedTokenBridgeMetaData.Bin

// DeployPeggedTokenBridge deploys a new Ethereum contract, binding an instance of PeggedTokenBridge to it.
func DeployPeggedTokenBridge(auth *bind.TransactOpts, backend bind.ContractBackend, _sigsVerifier common.Address) (common.Address, *types.Transaction, *PeggedTokenBridge, error) {
	parsed, err := PeggedTokenBridgeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PeggedTokenBridgeBin), backend, _sigsVerifier)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &PeggedTokenBridge{PeggedTokenBridgeCaller: PeggedTokenBridgeCaller{contract: contract}, PeggedTokenBridgeTransactor: PeggedTokenBridgeTransactor{contract: contract}, PeggedTokenBridgeFilterer: PeggedTokenBridgeFilterer{contract: contract}}, nil
}

// PeggedTokenBridge is an auto generated Go binding around an Ethereum contract.
type PeggedTokenBridge struct {
	PeggedTokenBridgeCaller     // Read-only binding to the contract
	PeggedTokenBridgeTransactor // Write-only binding to the contract
	PeggedTokenBridgeFilterer   // Log filterer for contract events
}

// PeggedTokenBridgeCaller is an auto generated read-only Go binding around an Ethereum contract.
type PeggedTokenBridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PeggedTokenBridgeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PeggedTokenBridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PeggedTokenBridgeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PeggedTokenBridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PeggedTokenBridgeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PeggedTokenBridgeSession struct {
	Contract     *PeggedTokenBridge // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// PeggedTokenBridgeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PeggedTokenBridgeCallerSession struct {
	Contract *PeggedTokenBridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// PeggedTokenBridgeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PeggedTokenBridgeTransactorSession struct {
	Contract     *PeggedTokenBridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// PeggedTokenBridgeRaw is an auto generated low-level Go binding around an Ethereum contract.
type PeggedTokenBridgeRaw struct {
	Contract *PeggedTokenBridge // Generic contract binding to access the raw methods on
}

// PeggedTokenBridgeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PeggedTokenBridgeCallerRaw struct {
	Contract *PeggedTokenBridgeCaller // Generic read-only contract binding to access the raw methods on
}

// PeggedTokenBridgeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PeggedTokenBridgeTransactorRaw struct {
	Contract *PeggedTokenBridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPeggedTokenBridge creates a new instance of PeggedTokenBridge, bound to a specific deployed contract.
func NewPeggedTokenBridge(address common.Address, backend bind.ContractBackend) (*PeggedTokenBridge, error) {
	contract, err := bindPeggedTokenBridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridge{PeggedTokenBridgeCaller: PeggedTokenBridgeCaller{contract: contract}, PeggedTokenBridgeTransactor: PeggedTokenBridgeTransactor{contract: contract}, PeggedTokenBridgeFilterer: PeggedTokenBridgeFilterer{contract: contract}}, nil
}

// NewPeggedTokenBridgeCaller creates a new read-only instance of PeggedTokenBridge, bound to a specific deployed contract.
func NewPeggedTokenBridgeCaller(address common.Address, caller bind.ContractCaller) (*PeggedTokenBridgeCaller, error) {
	contract, err := bindPeggedTokenBridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeCaller{contract: contract}, nil
}

// NewPeggedTokenBridgeTransactor creates a new write-only instance of PeggedTokenBridge, bound to a specific deployed contract.
func NewPeggedTokenBridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*PeggedTokenBridgeTransactor, error) {
	contract, err := bindPeggedTokenBridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeTransactor{contract: contract}, nil
}

// NewPeggedTokenBridgeFilterer creates a new log filterer instance of PeggedTokenBridge, bound to a specific deployed contract.
func NewPeggedTokenBridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*PeggedTokenBridgeFilterer, error) {
	contract, err := bindPeggedTokenBridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeFilterer{contract: contract}, nil
}

// bindPeggedTokenBridge binds a generic wrapper to an already deployed contract.
func bindPeggedTokenBridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(PeggedTokenBridgeABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PeggedTokenBridge *PeggedTokenBridgeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PeggedTokenBridge.Contract.PeggedTokenBridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PeggedTokenBridge *PeggedTokenBridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.PeggedTokenBridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PeggedTokenBridge *PeggedTokenBridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.PeggedTokenBridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PeggedTokenBridge *PeggedTokenBridgeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PeggedTokenBridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.contract.Transact(opts, method, params...)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) DelayPeriod(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "delayPeriod")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) DelayPeriod() (*big.Int, error) {
	return _PeggedTokenBridge.Contract.DelayPeriod(&_PeggedTokenBridge.CallOpts)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) DelayPeriod() (*big.Int, error) {
	return _PeggedTokenBridge.Contract.DelayPeriod(&_PeggedTokenBridge.CallOpts)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) DelayThresholds(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "delayThresholds", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.DelayThresholds(&_PeggedTokenBridge.CallOpts, arg0)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.DelayThresholds(&_PeggedTokenBridge.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) DelayedTransfers(opts *bind.CallOpts, arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "delayedTransfers", arg0)

	outstruct := new(struct {
		Receiver  common.Address
		Token     common.Address
		Amount    *big.Int
		Timestamp *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Receiver = *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	outstruct.Token = *abi.ConvertType(out[1], new(common.Address)).(*common.Address)
	outstruct.Amount = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.Timestamp = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _PeggedTokenBridge.Contract.DelayedTransfers(&_PeggedTokenBridge.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _PeggedTokenBridge.Contract.DelayedTransfers(&_PeggedTokenBridge.CallOpts, arg0)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) EpochLength(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "epochLength")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) EpochLength() (*big.Int, error) {
	return _PeggedTokenBridge.Contract.EpochLength(&_PeggedTokenBridge.CallOpts)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) EpochLength() (*big.Int, error) {
	return _PeggedTokenBridge.Contract.EpochLength(&_PeggedTokenBridge.CallOpts)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) EpochVolumeCaps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "epochVolumeCaps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.EpochVolumeCaps(&_PeggedTokenBridge.CallOpts, arg0)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.EpochVolumeCaps(&_PeggedTokenBridge.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) EpochVolumes(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "epochVolumes", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.EpochVolumes(&_PeggedTokenBridge.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.EpochVolumes(&_PeggedTokenBridge.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) Governors(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "governors", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Governors(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.Governors(&_PeggedTokenBridge.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) Governors(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.Governors(&_PeggedTokenBridge.CallOpts, arg0)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) IsGovernor(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "isGovernor", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) IsGovernor(_account common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.IsGovernor(&_PeggedTokenBridge.CallOpts, _account)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) IsGovernor(_account common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.IsGovernor(&_PeggedTokenBridge.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) IsPauser(account common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.IsPauser(&_PeggedTokenBridge.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) IsPauser(account common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.IsPauser(&_PeggedTokenBridge.CallOpts, account)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) LastOpTimestamps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "lastOpTimestamps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.LastOpTimestamps(&_PeggedTokenBridge.CallOpts, arg0)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.LastOpTimestamps(&_PeggedTokenBridge.CallOpts, arg0)
}

// MaxBurn is a free data retrieval call binding the contract method 0x497bf3b2.
//
// Solidity: function maxBurn(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) MaxBurn(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "maxBurn", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxBurn is a free data retrieval call binding the contract method 0x497bf3b2.
//
// Solidity: function maxBurn(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) MaxBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.MaxBurn(&_PeggedTokenBridge.CallOpts, arg0)
}

// MaxBurn is a free data retrieval call binding the contract method 0x497bf3b2.
//
// Solidity: function maxBurn(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) MaxBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.MaxBurn(&_PeggedTokenBridge.CallOpts, arg0)
}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) MinBurn(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "minBurn", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) MinBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.MinBurn(&_PeggedTokenBridge.CallOpts, arg0)
}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) MinBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.MinBurn(&_PeggedTokenBridge.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Owner() (common.Address, error) {
	return _PeggedTokenBridge.Contract.Owner(&_PeggedTokenBridge.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) Owner() (common.Address, error) {
	return _PeggedTokenBridge.Contract.Owner(&_PeggedTokenBridge.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Paused() (bool, error) {
	return _PeggedTokenBridge.Contract.Paused(&_PeggedTokenBridge.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) Paused() (bool, error) {
	return _PeggedTokenBridge.Contract.Paused(&_PeggedTokenBridge.CallOpts)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Pausers(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.Pausers(&_PeggedTokenBridge.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.Pausers(&_PeggedTokenBridge.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) Records(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "records", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Records(arg0 [32]byte) (bool, error) {
	return _PeggedTokenBridge.Contract.Records(&_PeggedTokenBridge.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) Records(arg0 [32]byte) (bool, error) {
	return _PeggedTokenBridge.Contract.Records(&_PeggedTokenBridge.CallOpts, arg0)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) SigsVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "sigsVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) SigsVerifier() (common.Address, error) {
	return _PeggedTokenBridge.Contract.SigsVerifier(&_PeggedTokenBridge.CallOpts)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) SigsVerifier() (common.Address, error) {
	return _PeggedTokenBridge.Contract.SigsVerifier(&_PeggedTokenBridge.CallOpts)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) AddGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "addGovernor", _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.AddGovernor(&_PeggedTokenBridge.TransactOpts, _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.AddGovernor(&_PeggedTokenBridge.TransactOpts, _account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.AddPauser(&_PeggedTokenBridge.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.AddPauser(&_PeggedTokenBridge.TransactOpts, account)
}

// Burn is a paid mutator transaction binding the contract method 0xde790c7e.
//
// Solidity: function burn(address _token, uint256 _amount, address _withdrawAccount, uint64 _nonce) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) Burn(opts *bind.TransactOpts, _token common.Address, _amount *big.Int, _withdrawAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "burn", _token, _amount, _withdrawAccount, _nonce)
}

// Burn is a paid mutator transaction binding the contract method 0xde790c7e.
//
// Solidity: function burn(address _token, uint256 _amount, address _withdrawAccount, uint64 _nonce) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Burn(_token common.Address, _amount *big.Int, _withdrawAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Burn(&_PeggedTokenBridge.TransactOpts, _token, _amount, _withdrawAccount, _nonce)
}

// Burn is a paid mutator transaction binding the contract method 0xde790c7e.
//
// Solidity: function burn(address _token, uint256 _amount, address _withdrawAccount, uint64 _nonce) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) Burn(_token common.Address, _amount *big.Int, _withdrawAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Burn(&_PeggedTokenBridge.TransactOpts, _token, _amount, _withdrawAccount, _nonce)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) ExecuteDelayedTransfer(opts *bind.TransactOpts, id [32]byte) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "executeDelayedTransfer", id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.ExecuteDelayedTransfer(&_PeggedTokenBridge.TransactOpts, id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.ExecuteDelayedTransfer(&_PeggedTokenBridge.TransactOpts, id)
}

// Mint is a paid mutator transaction binding the contract method 0xf8734302.
//
// Solidity: function mint(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) Mint(opts *bind.TransactOpts, _request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "mint", _request, _sigs, _signers, _powers)
}

// Mint is a paid mutator transaction binding the contract method 0xf8734302.
//
// Solidity: function mint(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Mint(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Mint(&_PeggedTokenBridge.TransactOpts, _request, _sigs, _signers, _powers)
}

// Mint is a paid mutator transaction binding the contract method 0xf8734302.
//
// Solidity: function mint(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) Mint(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Mint(&_PeggedTokenBridge.TransactOpts, _request, _sigs, _signers, _powers)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Pause() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Pause(&_PeggedTokenBridge.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) Pause() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Pause(&_PeggedTokenBridge.TransactOpts)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) RemoveGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "removeGovernor", _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RemoveGovernor(&_PeggedTokenBridge.TransactOpts, _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RemoveGovernor(&_PeggedTokenBridge.TransactOpts, _account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RemovePauser(&_PeggedTokenBridge.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RemovePauser(&_PeggedTokenBridge.TransactOpts, account)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) RenounceGovernor(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "renounceGovernor")
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) RenounceGovernor() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RenounceGovernor(&_PeggedTokenBridge.TransactOpts)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) RenounceGovernor() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RenounceGovernor(&_PeggedTokenBridge.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) RenouncePauser() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RenouncePauser(&_PeggedTokenBridge.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RenouncePauser(&_PeggedTokenBridge.TransactOpts)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) SetDelayPeriod(opts *bind.TransactOpts, _period *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "setDelayPeriod", _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetDelayPeriod(&_PeggedTokenBridge.TransactOpts, _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetDelayPeriod(&_PeggedTokenBridge.TransactOpts, _period)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) SetDelayThresholds(opts *bind.TransactOpts, _tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "setDelayThresholds", _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetDelayThresholds(&_PeggedTokenBridge.TransactOpts, _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetDelayThresholds(&_PeggedTokenBridge.TransactOpts, _tokens, _thresholds)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) SetEpochLength(opts *bind.TransactOpts, _length *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "setEpochLength", _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetEpochLength(&_PeggedTokenBridge.TransactOpts, _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetEpochLength(&_PeggedTokenBridge.TransactOpts, _length)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) SetEpochVolumeCaps(opts *bind.TransactOpts, _tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "setEpochVolumeCaps", _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetEpochVolumeCaps(&_PeggedTokenBridge.TransactOpts, _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetEpochVolumeCaps(&_PeggedTokenBridge.TransactOpts, _tokens, _caps)
}

// SetMaxBurn is a paid mutator transaction binding the contract method 0xf9a8ea08.
//
// Solidity: function setMaxBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) SetMaxBurn(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "setMaxBurn", _tokens, _amounts)
}

// SetMaxBurn is a paid mutator transaction binding the contract method 0xf9a8ea08.
//
// Solidity: function setMaxBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) SetMaxBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetMaxBurn(&_PeggedTokenBridge.TransactOpts, _tokens, _amounts)
}

// SetMaxBurn is a paid mutator transaction binding the contract method 0xf9a8ea08.
//
// Solidity: function setMaxBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) SetMaxBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetMaxBurn(&_PeggedTokenBridge.TransactOpts, _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) SetMinBurn(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "setMinBurn", _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) SetMinBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetMinBurn(&_PeggedTokenBridge.TransactOpts, _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) SetMinBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetMinBurn(&_PeggedTokenBridge.TransactOpts, _tokens, _amounts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.TransferOwnership(&_PeggedTokenBridge.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.TransferOwnership(&_PeggedTokenBridge.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Unpause() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Unpause(&_PeggedTokenBridge.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) Unpause() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Unpause(&_PeggedTokenBridge.TransactOpts)
}

// PeggedTokenBridgeBurnIterator is returned from FilterBurn and is used to iterate over the raw logs and unpacked data for Burn events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeBurnIterator struct {
	Event *PeggedTokenBridgeBurn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeBurnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeBurn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeBurn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeBurnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeBurnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeBurn represents a Burn event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeBurn struct {
	BurnId          [32]byte
	Token           common.Address
	Account         common.Address
	Amount          *big.Int
	WithdrawAccount common.Address
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterBurn is a free log retrieval operation binding the contract event 0x75f1bf55bb1de41b63a775dc7d4500f01114ee62b688a6b11d34f4692c1f3d43.
//
// Solidity: event Burn(bytes32 burnId, address token, address account, uint256 amount, address withdrawAccount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterBurn(opts *bind.FilterOpts) (*PeggedTokenBridgeBurnIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "Burn")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeBurnIterator{contract: _PeggedTokenBridge.contract, event: "Burn", logs: logs, sub: sub}, nil
}

// WatchBurn is a free log subscription operation binding the contract event 0x75f1bf55bb1de41b63a775dc7d4500f01114ee62b688a6b11d34f4692c1f3d43.
//
// Solidity: event Burn(bytes32 burnId, address token, address account, uint256 amount, address withdrawAccount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchBurn(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeBurn) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "Burn")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeBurn)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "Burn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBurn is a log parse operation binding the contract event 0x75f1bf55bb1de41b63a775dc7d4500f01114ee62b688a6b11d34f4692c1f3d43.
//
// Solidity: event Burn(bytes32 burnId, address token, address account, uint256 amount, address withdrawAccount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseBurn(log types.Log) (*PeggedTokenBridgeBurn, error) {
	event := new(PeggedTokenBridgeBurn)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "Burn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeDelayPeriodUpdatedIterator is returned from FilterDelayPeriodUpdated and is used to iterate over the raw logs and unpacked data for DelayPeriodUpdated events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayPeriodUpdatedIterator struct {
	Event *PeggedTokenBridgeDelayPeriodUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeDelayPeriodUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeDelayPeriodUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeDelayPeriodUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeDelayPeriodUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeDelayPeriodUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeDelayPeriodUpdated represents a DelayPeriodUpdated event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayPeriodUpdated struct {
	Period *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterDelayPeriodUpdated is a free log retrieval operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterDelayPeriodUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeDelayPeriodUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeDelayPeriodUpdatedIterator{contract: _PeggedTokenBridge.contract, event: "DelayPeriodUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayPeriodUpdated is a free log subscription operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchDelayPeriodUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeDelayPeriodUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeDelayPeriodUpdated)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayPeriodUpdated is a log parse operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseDelayPeriodUpdated(log types.Log) (*PeggedTokenBridgeDelayPeriodUpdated, error) {
	event := new(PeggedTokenBridgeDelayPeriodUpdated)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeDelayThresholdUpdatedIterator is returned from FilterDelayThresholdUpdated and is used to iterate over the raw logs and unpacked data for DelayThresholdUpdated events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayThresholdUpdatedIterator struct {
	Event *PeggedTokenBridgeDelayThresholdUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeDelayThresholdUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeDelayThresholdUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeDelayThresholdUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeDelayThresholdUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeDelayThresholdUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeDelayThresholdUpdated represents a DelayThresholdUpdated event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayThresholdUpdated struct {
	Token     common.Address
	Threshold *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterDelayThresholdUpdated is a free log retrieval operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterDelayThresholdUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeDelayThresholdUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeDelayThresholdUpdatedIterator{contract: _PeggedTokenBridge.contract, event: "DelayThresholdUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayThresholdUpdated is a free log subscription operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchDelayThresholdUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeDelayThresholdUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeDelayThresholdUpdated)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayThresholdUpdated is a log parse operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseDelayThresholdUpdated(log types.Log) (*PeggedTokenBridgeDelayThresholdUpdated, error) {
	event := new(PeggedTokenBridgeDelayThresholdUpdated)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeDelayedTransferAddedIterator is returned from FilterDelayedTransferAdded and is used to iterate over the raw logs and unpacked data for DelayedTransferAdded events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayedTransferAddedIterator struct {
	Event *PeggedTokenBridgeDelayedTransferAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeDelayedTransferAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeDelayedTransferAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeDelayedTransferAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeDelayedTransferAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeDelayedTransferAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeDelayedTransferAdded represents a DelayedTransferAdded event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayedTransferAdded struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferAdded is a free log retrieval operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterDelayedTransferAdded(opts *bind.FilterOpts) (*PeggedTokenBridgeDelayedTransferAddedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeDelayedTransferAddedIterator{contract: _PeggedTokenBridge.contract, event: "DelayedTransferAdded", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferAdded is a free log subscription operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchDelayedTransferAdded(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeDelayedTransferAdded) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeDelayedTransferAdded)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferAdded is a log parse operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseDelayedTransferAdded(log types.Log) (*PeggedTokenBridgeDelayedTransferAdded, error) {
	event := new(PeggedTokenBridgeDelayedTransferAdded)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeDelayedTransferExecutedIterator is returned from FilterDelayedTransferExecuted and is used to iterate over the raw logs and unpacked data for DelayedTransferExecuted events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayedTransferExecutedIterator struct {
	Event *PeggedTokenBridgeDelayedTransferExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeDelayedTransferExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeDelayedTransferExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeDelayedTransferExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeDelayedTransferExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeDelayedTransferExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeDelayedTransferExecuted represents a DelayedTransferExecuted event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayedTransferExecuted struct {
	Id       [32]byte
	Receiver common.Address
	Token    common.Address
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferExecuted is a free log retrieval operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterDelayedTransferExecuted(opts *bind.FilterOpts) (*PeggedTokenBridgeDelayedTransferExecutedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeDelayedTransferExecutedIterator{contract: _PeggedTokenBridge.contract, event: "DelayedTransferExecuted", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferExecuted is a free log subscription operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchDelayedTransferExecuted(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeDelayedTransferExecuted) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeDelayedTransferExecuted)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferExecuted is a log parse operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseDelayedTransferExecuted(log types.Log) (*PeggedTokenBridgeDelayedTransferExecuted, error) {
	event := new(PeggedTokenBridgeDelayedTransferExecuted)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeEpochLengthUpdatedIterator is returned from FilterEpochLengthUpdated and is used to iterate over the raw logs and unpacked data for EpochLengthUpdated events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeEpochLengthUpdatedIterator struct {
	Event *PeggedTokenBridgeEpochLengthUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeEpochLengthUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeEpochLengthUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeEpochLengthUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeEpochLengthUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeEpochLengthUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeEpochLengthUpdated represents a EpochLengthUpdated event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeEpochLengthUpdated struct {
	Length *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterEpochLengthUpdated is a free log retrieval operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterEpochLengthUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeEpochLengthUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeEpochLengthUpdatedIterator{contract: _PeggedTokenBridge.contract, event: "EpochLengthUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochLengthUpdated is a free log subscription operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchEpochLengthUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeEpochLengthUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeEpochLengthUpdated)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochLengthUpdated is a log parse operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseEpochLengthUpdated(log types.Log) (*PeggedTokenBridgeEpochLengthUpdated, error) {
	event := new(PeggedTokenBridgeEpochLengthUpdated)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeEpochVolumeUpdatedIterator is returned from FilterEpochVolumeUpdated and is used to iterate over the raw logs and unpacked data for EpochVolumeUpdated events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeEpochVolumeUpdatedIterator struct {
	Event *PeggedTokenBridgeEpochVolumeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeEpochVolumeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeEpochVolumeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeEpochVolumeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeEpochVolumeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeEpochVolumeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeEpochVolumeUpdated represents a EpochVolumeUpdated event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeEpochVolumeUpdated struct {
	Token common.Address
	Cap   *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterEpochVolumeUpdated is a free log retrieval operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterEpochVolumeUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeEpochVolumeUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeEpochVolumeUpdatedIterator{contract: _PeggedTokenBridge.contract, event: "EpochVolumeUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochVolumeUpdated is a free log subscription operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchEpochVolumeUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeEpochVolumeUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeEpochVolumeUpdated)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochVolumeUpdated is a log parse operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseEpochVolumeUpdated(log types.Log) (*PeggedTokenBridgeEpochVolumeUpdated, error) {
	event := new(PeggedTokenBridgeEpochVolumeUpdated)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeGovernorAddedIterator is returned from FilterGovernorAdded and is used to iterate over the raw logs and unpacked data for GovernorAdded events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeGovernorAddedIterator struct {
	Event *PeggedTokenBridgeGovernorAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeGovernorAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeGovernorAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeGovernorAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeGovernorAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeGovernorAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeGovernorAdded represents a GovernorAdded event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeGovernorAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorAdded is a free log retrieval operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterGovernorAdded(opts *bind.FilterOpts) (*PeggedTokenBridgeGovernorAddedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeGovernorAddedIterator{contract: _PeggedTokenBridge.contract, event: "GovernorAdded", logs: logs, sub: sub}, nil
}

// WatchGovernorAdded is a free log subscription operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchGovernorAdded(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeGovernorAdded) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeGovernorAdded)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorAdded is a log parse operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseGovernorAdded(log types.Log) (*PeggedTokenBridgeGovernorAdded, error) {
	event := new(PeggedTokenBridgeGovernorAdded)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeGovernorRemovedIterator is returned from FilterGovernorRemoved and is used to iterate over the raw logs and unpacked data for GovernorRemoved events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeGovernorRemovedIterator struct {
	Event *PeggedTokenBridgeGovernorRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeGovernorRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeGovernorRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeGovernorRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeGovernorRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeGovernorRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeGovernorRemoved represents a GovernorRemoved event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeGovernorRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorRemoved is a free log retrieval operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterGovernorRemoved(opts *bind.FilterOpts) (*PeggedTokenBridgeGovernorRemovedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeGovernorRemovedIterator{contract: _PeggedTokenBridge.contract, event: "GovernorRemoved", logs: logs, sub: sub}, nil
}

// WatchGovernorRemoved is a free log subscription operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchGovernorRemoved(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeGovernorRemoved) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeGovernorRemoved)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorRemoved is a log parse operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseGovernorRemoved(log types.Log) (*PeggedTokenBridgeGovernorRemoved, error) {
	event := new(PeggedTokenBridgeGovernorRemoved)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeMaxBurnUpdatedIterator is returned from FilterMaxBurnUpdated and is used to iterate over the raw logs and unpacked data for MaxBurnUpdated events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeMaxBurnUpdatedIterator struct {
	Event *PeggedTokenBridgeMaxBurnUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeMaxBurnUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeMaxBurnUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeMaxBurnUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeMaxBurnUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeMaxBurnUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeMaxBurnUpdated represents a MaxBurnUpdated event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeMaxBurnUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMaxBurnUpdated is a free log retrieval operation binding the contract event 0xa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da5.
//
// Solidity: event MaxBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterMaxBurnUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeMaxBurnUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "MaxBurnUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeMaxBurnUpdatedIterator{contract: _PeggedTokenBridge.contract, event: "MaxBurnUpdated", logs: logs, sub: sub}, nil
}

// WatchMaxBurnUpdated is a free log subscription operation binding the contract event 0xa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da5.
//
// Solidity: event MaxBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchMaxBurnUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeMaxBurnUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "MaxBurnUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeMaxBurnUpdated)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "MaxBurnUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMaxBurnUpdated is a log parse operation binding the contract event 0xa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da5.
//
// Solidity: event MaxBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseMaxBurnUpdated(log types.Log) (*PeggedTokenBridgeMaxBurnUpdated, error) {
	event := new(PeggedTokenBridgeMaxBurnUpdated)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "MaxBurnUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeMinBurnUpdatedIterator is returned from FilterMinBurnUpdated and is used to iterate over the raw logs and unpacked data for MinBurnUpdated events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeMinBurnUpdatedIterator struct {
	Event *PeggedTokenBridgeMinBurnUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeMinBurnUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeMinBurnUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeMinBurnUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeMinBurnUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeMinBurnUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeMinBurnUpdated represents a MinBurnUpdated event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeMinBurnUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMinBurnUpdated is a free log retrieval operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterMinBurnUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeMinBurnUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "MinBurnUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeMinBurnUpdatedIterator{contract: _PeggedTokenBridge.contract, event: "MinBurnUpdated", logs: logs, sub: sub}, nil
}

// WatchMinBurnUpdated is a free log subscription operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchMinBurnUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeMinBurnUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "MinBurnUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeMinBurnUpdated)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "MinBurnUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinBurnUpdated is a log parse operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseMinBurnUpdated(log types.Log) (*PeggedTokenBridgeMinBurnUpdated, error) {
	event := new(PeggedTokenBridgeMinBurnUpdated)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "MinBurnUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeMintIterator is returned from FilterMint and is used to iterate over the raw logs and unpacked data for Mint events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeMintIterator struct {
	Event *PeggedTokenBridgeMint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeMintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeMint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeMint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeMintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeMintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeMint represents a Mint event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeMint struct {
	MintId     [32]byte
	Token      common.Address
	Account    common.Address
	Amount     *big.Int
	RefChainId uint64
	RefId      [32]byte
	Depositor  common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterMint is a free log retrieval operation binding the contract event 0x5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a.
//
// Solidity: event Mint(bytes32 mintId, address token, address account, uint256 amount, uint64 refChainId, bytes32 refId, address depositor)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterMint(opts *bind.FilterOpts) (*PeggedTokenBridgeMintIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "Mint")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeMintIterator{contract: _PeggedTokenBridge.contract, event: "Mint", logs: logs, sub: sub}, nil
}

// WatchMint is a free log subscription operation binding the contract event 0x5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a.
//
// Solidity: event Mint(bytes32 mintId, address token, address account, uint256 amount, uint64 refChainId, bytes32 refId, address depositor)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchMint(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeMint) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "Mint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeMint)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "Mint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMint is a log parse operation binding the contract event 0x5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a.
//
// Solidity: event Mint(bytes32 mintId, address token, address account, uint256 amount, uint64 refChainId, bytes32 refId, address depositor)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseMint(log types.Log) (*PeggedTokenBridgeMint, error) {
	event := new(PeggedTokenBridgeMint)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "Mint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeOwnershipTransferredIterator struct {
	Event *PeggedTokenBridgeOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeOwnershipTransferred represents a OwnershipTransferred event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*PeggedTokenBridgeOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeOwnershipTransferredIterator{contract: _PeggedTokenBridge.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeOwnershipTransferred)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseOwnershipTransferred(log types.Log) (*PeggedTokenBridgeOwnershipTransferred, error) {
	event := new(PeggedTokenBridgeOwnershipTransferred)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgePausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgePausedIterator struct {
	Event *PeggedTokenBridgePaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgePausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgePaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgePaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgePausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgePausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgePaused represents a Paused event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgePaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterPaused(opts *bind.FilterOpts) (*PeggedTokenBridgePausedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgePausedIterator{contract: _PeggedTokenBridge.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgePaused) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgePaused)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParsePaused(log types.Log) (*PeggedTokenBridgePaused, error) {
	event := new(PeggedTokenBridgePaused)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgePauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgePauserAddedIterator struct {
	Event *PeggedTokenBridgePauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgePauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgePauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgePauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgePauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgePauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgePauserAdded represents a PauserAdded event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgePauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*PeggedTokenBridgePauserAddedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgePauserAddedIterator{contract: _PeggedTokenBridge.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgePauserAdded) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgePauserAdded)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParsePauserAdded(log types.Log) (*PeggedTokenBridgePauserAdded, error) {
	event := new(PeggedTokenBridgePauserAdded)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgePauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgePauserRemovedIterator struct {
	Event *PeggedTokenBridgePauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgePauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgePauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgePauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgePauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgePauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgePauserRemoved represents a PauserRemoved event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgePauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*PeggedTokenBridgePauserRemovedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgePauserRemovedIterator{contract: _PeggedTokenBridge.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgePauserRemoved) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgePauserRemoved)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParsePauserRemoved(log types.Log) (*PeggedTokenBridgePauserRemoved, error) {
	event := new(PeggedTokenBridgePauserRemoved)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeUnpausedIterator struct {
	Event *PeggedTokenBridgeUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeUnpaused represents a Unpaused event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterUnpaused(opts *bind.FilterOpts) (*PeggedTokenBridgeUnpausedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeUnpausedIterator{contract: _PeggedTokenBridge.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeUnpaused) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeUnpaused)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseUnpaused(log types.Log) (*PeggedTokenBridgeUnpaused, error) {
	event := new(PeggedTokenBridgeUnpaused)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
